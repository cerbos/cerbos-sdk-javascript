diff --git a/node_modules/ts-proto/build/main.js b/node_modules/ts-proto/build/main.js
index 96015b3..251017d 100644
--- a/node_modules/ts-proto/build/main.js
+++ b/node_modules/ts-proto/build/main.js
@@ -1662,9 +1662,7 @@ function generateToJson(ctx, fullName, fullProtobufTypeName, messageDesc) {
         const readSnippet = (from) => {
             if ((0, types_1.isEnum)(field)) {
                 const toJson = (0, types_1.getEnumMethod)(ctx, field.typeName, "ToJSON");
-                return (0, types_1.isWithinOneOf)(field)
-                    ? (0, ts_poet_1.code) `${from} !== undefined ? ${toJson}(${from}) : undefined`
-                    : (0, ts_poet_1.code) `${toJson}(${from})`;
+                return (0, ts_poet_1.code) `${toJson}(${from})`;
             }
             else if ((0, types_1.isObjectId)(field) && options.useMongoObjectId) {
                 return (0, ts_poet_1.code) `${from}.toString()`;
@@ -1729,19 +1727,13 @@ function generateToJson(ctx, fullName, fullProtobufTypeName, messageDesc) {
             }
             else if ((0, types_1.isMessage)(field) && !(0, types_1.isValueType)(ctx, field) && !(0, types_1.isMapType)(ctx, messageDesc, field)) {
                 const type = (0, types_1.basicTypeName)(ctx, field, { keepValueType: true });
-                return (0, ts_poet_1.code) `${from} ? ${type}.toJSON(${from}) : ${(0, types_1.defaultValue)(ctx, field)}`;
+                return (0, ts_poet_1.code) `${type}.toJSON(${from})`;
             }
             else if ((0, types_1.isBytes)(field)) {
-                if ((0, types_1.isWithinOneOf)(field)) {
-                    return (0, ts_poet_1.code) `${from} !== undefined ? ${utils.base64FromBytes}(${from}) : undefined`;
-                }
-                else {
-                    return (0, ts_poet_1.code) `${utils.base64FromBytes}(${from} !== undefined ? ${from} : ${(0, types_1.defaultValue)(ctx, field)})`;
-                }
+                return (0, ts_poet_1.code) `${utils.base64FromBytes}(${from})`;
             }
             else if ((0, types_1.isLong)(field) && options.forceLong === options_1.LongOption.LONG) {
-                const v = (0, types_1.isWithinOneOf)(field) ? "undefined" : (0, types_1.defaultValue)(ctx, field);
-                return (0, ts_poet_1.code) `(${from} || ${v}).toString()`;
+                return (0, ts_poet_1.code) `(${from} || ${(0, types_1.defaultValue)(ctx, field)}).toString()`;
             }
             else if ((0, types_1.isLong)(field) && options.forceLong === options_1.LongOption.BIGINT) {
                 return (0, ts_poet_1.code) `${from}.toString()`;
@@ -1758,8 +1750,8 @@ function generateToJson(ctx, fullName, fullProtobufTypeName, messageDesc) {
             const i = convertToObjectKey(ctx, messageDesc, field, "k");
             if (ctx.options.useMapType) {
                 chunks.push((0, ts_poet_1.code) `
-          ${jsonProperty} = {};
-          if (message.${fieldName}) {
+          if (message.${fieldName}?.size) {
+            ${jsonProperty} = {};
             message.${fieldName}.forEach((v, k) => {
               ${jsonProperty}[${i}] = ${readSnippet("v")};
             });
@@ -1768,34 +1760,46 @@ function generateToJson(ctx, fullName, fullProtobufTypeName, messageDesc) {
             }
             else {
                 chunks.push((0, ts_poet_1.code) `
-          ${jsonProperty} = {};
-          if (message.${fieldName}) {
-            Object.entries(message.${fieldName}).forEach(([k, v]) => {
-              ${jsonProperty}[${i}] = ${readSnippet("v")};
-            });
+        if (message.${fieldName}) {
+            const entries = Object.entries(message.${fieldName});
+            if (entries.length > 0) {
+              ${jsonProperty} = {};
+              entries.forEach(([k, v]) => {
+                ${jsonProperty}[${i}] = ${readSnippet("v")};
+              });
+            }
           }
         `);
             }
         }
         else if ((0, types_1.isRepeated)(field)) {
             // Arrays might need their elements transformed
+            const transformElement = readSnippet("e");
+            const maybeMap = transformElement.toCodeString([]) !== "e" ? (0, ts_poet_1.code) `.map(e => ${transformElement})` : "";
             chunks.push((0, ts_poet_1.code) `
-        if (message.${fieldName}) {
-          ${jsonProperty} = message.${fieldName}.map(e => ${readSnippet("e")});
-        } else {
-          ${jsonProperty} = [];
+        if (message.${fieldName}?.length) {
+          ${jsonProperty} = message.${fieldName}${maybeMap};
         }
       `);
         }
         else if ((0, types_1.isWithinOneOfThatShouldBeUnion)(options, field)) {
             // oneofs in a union are only output as `oneof name = ...`
             const oneofName = (0, case_1.maybeSnakeToCamel)(messageDesc.oneofDecl[field.oneofIndex].name, options);
-            const v = readSnippet(`message.${oneofName}?.${fieldName}`);
-            chunks.push((0, ts_poet_1.code) `message.${oneofName}?.$case === '${fieldName}' && (${jsonProperty} = ${v});`);
+            chunks.push((0, ts_poet_1.code) `
+        if (message.${oneofName}?.$case === '${fieldName}') {
+          ${jsonProperty} = ${readSnippet(`message.${oneofName}.${fieldName}`)};
+        }
+      `);
         }
         else {
-            const v = readSnippet(`message.${fieldName}`);
-            chunks.push((0, ts_poet_1.code) `message.${fieldName} !== undefined && (${jsonProperty} = ${v});`);
+            const check = ((0, types_1.isScalar)(field) || (0, types_1.isEnum)(field)) && !(0, types_1.isWithinOneOf)(field)
+                ? (0, types_1.notDefaultCheck)(ctx, field, messageDesc.options, `message.${fieldName}`)
+                : `message.${fieldName} !== undefined`;
+            chunks.push((0, ts_poet_1.code) `
+        if (${check}) {
+          ${jsonProperty} = ${readSnippet(`message.${fieldName}`)};
+        }
+      `);
         }
     });
     chunks.push((0, ts_poet_1.code) `return obj;`);
diff --git a/node_modules/ts-proto/build/utils.js b/node_modules/ts-proto/build/utils.js
index aab20fb..961506b 100644
--- a/node_modules/ts-proto/build/utils.js
+++ b/node_modules/ts-proto/build/utils.js
@@ -80,37 +80,6 @@ exports.upperFirst = upperFirst;
 const CloseComment = /\*\//g;
 /** Removes potentially harmful characters from comments and pushes it into chunks. */
 function maybeAddComment(desc, chunks, deprecated, prefix = "") {
-    let lines = [];
-    if (desc.leadingComments || desc.trailingComments) {
-        let content = (desc.leadingComments || desc.trailingComments || "").replace(CloseComment, "* /").trim();
-        // Detect /** ... */ comments
-        const isDoubleStar = content.startsWith("*");
-        if (isDoubleStar) {
-            content = content.substring(1).trim();
-        }
-        // Prefix things like the enum name.
-        if (prefix) {
-            content = prefix + content;
-        }
-        lines = content.split("\n").map((l) => l.replace(/^ /, "").replace(/\n/, ""));
-    }
-    // Deprecated comment should be added even if no other comment was added
-    if (deprecated) {
-        if (lines.length > 0) {
-            lines.push("");
-        }
-        lines.push("@deprecated");
-    }
-    let comment;
-    if (lines.length === 1) {
-        comment = (0, ts_poet_1.code) `/** ${lines[0]} */`;
-    }
-    else {
-        comment = (0, ts_poet_1.code) `/**\n * ${lines.join("\n * ")}\n */`;
-    }
-    if (lines.length > 0) {
-        chunks.push((0, ts_poet_1.code) `\n\n${comment}\n\n`);
-    }
 }
 exports.maybeAddComment = maybeAddComment;
 // Comment block at the top of every source file, since these comments require specific

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: cerbos/response/v1/response.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty } from "../../../google/protobuf/empty";
import { Value } from "../../../google/protobuf/struct";
import { AccessLogEntry, DecisionLogEntry } from "../../audit/v1/audit";
import { Effect } from "../../effect/v1/effect";
import { OutputEntry, PlanResourcesFilter } from "../../engine/v1/engine";
import { Policy } from "../../policy/v1/policy";
import { Schema, ValidationError } from "../../schema/v1/schema";

export const protobufPackage = "cerbos.response.v1";

export interface PlanResourcesResponse {
  requestId: string;
  action: string;
  resourceKind: string;
  policyVersion: string;
  filter: PlanResourcesFilter | undefined;
  meta: PlanResourcesResponse_Meta | undefined;
  validationErrors: ValidationError[];
  cerbosCallId: string;
}

export interface PlanResourcesResponse_Meta {
  filterDebug: string;
  matchedScope: string;
}

export interface CheckResourceSetResponse {
  requestId: string;
  resourceInstances: {
    [key: string]: CheckResourceSetResponse_ActionEffectMap;
  };
  meta: CheckResourceSetResponse_Meta | undefined;
}

export interface CheckResourceSetResponse_ActionEffectMap {
  actions: { [key: string]: Effect };
  validationErrors: ValidationError[];
}

export interface CheckResourceSetResponse_ActionEffectMap_ActionsEntry {
  key: string;
  value: Effect;
}

export interface CheckResourceSetResponse_Meta {
  resourceInstances: {
    [key: string]: CheckResourceSetResponse_Meta_ActionMeta;
  };
}

export interface CheckResourceSetResponse_Meta_EffectMeta {
  matchedPolicy: string;
  matchedScope: string;
}

export interface CheckResourceSetResponse_Meta_ActionMeta {
  actions: { [key: string]: CheckResourceSetResponse_Meta_EffectMeta };
  effectiveDerivedRoles: string[];
}

export interface CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry {
  key: string;
  value: CheckResourceSetResponse_Meta_EffectMeta | undefined;
}

export interface CheckResourceSetResponse_Meta_ResourceInstancesEntry {
  key: string;
  value: CheckResourceSetResponse_Meta_ActionMeta | undefined;
}

export interface CheckResourceSetResponse_ResourceInstancesEntry {
  key: string;
  value: CheckResourceSetResponse_ActionEffectMap | undefined;
}

export interface CheckResourceBatchResponse {
  requestId: string;
  results: CheckResourceBatchResponse_ActionEffectMap[];
}

export interface CheckResourceBatchResponse_ActionEffectMap {
  resourceId: string;
  actions: { [key: string]: Effect };
  validationErrors: ValidationError[];
}

export interface CheckResourceBatchResponse_ActionEffectMap_ActionsEntry {
  key: string;
  value: Effect;
}

export interface CheckResourcesResponse {
  requestId: string;
  results: CheckResourcesResponse_ResultEntry[];
  cerbosCallId: string;
}

export interface CheckResourcesResponse_ResultEntry {
  resource: CheckResourcesResponse_ResultEntry_Resource | undefined;
  actions: { [key: string]: Effect };
  validationErrors: ValidationError[];
  meta: CheckResourcesResponse_ResultEntry_Meta | undefined;
  outputs: OutputEntry[];
}

export interface CheckResourcesResponse_ResultEntry_Resource {
  id: string;
  kind: string;
  policyVersion: string;
  scope: string;
}

export interface CheckResourcesResponse_ResultEntry_Meta {
  actions: {
    [key: string]: CheckResourcesResponse_ResultEntry_Meta_EffectMeta;
  };
  effectiveDerivedRoles: string[];
}

export interface CheckResourcesResponse_ResultEntry_Meta_EffectMeta {
  matchedPolicy: string;
  matchedScope: string;
}

export interface CheckResourcesResponse_ResultEntry_Meta_ActionsEntry {
  key: string;
  value: CheckResourcesResponse_ResultEntry_Meta_EffectMeta | undefined;
}

export interface CheckResourcesResponse_ResultEntry_ActionsEntry {
  key: string;
  value: Effect;
}

export interface AddOrUpdatePolicyResponse {
  success: Empty | undefined;
}

export interface ListAuditLogEntriesResponse {
  entry?:
    | { $case: "accessLogEntry"; accessLogEntry: AccessLogEntry }
    | {
        $case: "decisionLogEntry";
        decisionLogEntry: DecisionLogEntry;
      }
    | undefined;
}

export interface ServerInfoResponse {
  version: string;
  commit: string;
  buildDate: string;
}

export interface ListPoliciesResponse {
  policyIds: string[];
}

export interface GetPolicyResponse {
  policies: Policy[];
}

export interface DisablePolicyResponse {
  disabledPolicies: number;
}

export interface EnablePolicyResponse {
  enabledPolicies: number;
}

export interface InspectPoliciesResponse {
  results: { [key: string]: InspectPoliciesResponse_Result };
}

export interface InspectPoliciesResponse_Attribute {
  kind: InspectPoliciesResponse_Attribute_Kind;
  name: string;
}

export enum InspectPoliciesResponse_Attribute_Kind {
  KIND_UNSPECIFIED = 0,
  KIND_PRINCIPAL_ATTRIBUTE = 1,
  KIND_RESOURCE_ATTRIBUTE = 2,
}

export interface InspectPoliciesResponse_DerivedRole {
  name: string;
  kind: InspectPoliciesResponse_DerivedRole_Kind;
  source: string;
}

export enum InspectPoliciesResponse_DerivedRole_Kind {
  KIND_UNSPECIFIED = 0,
  KIND_UNDEFINED = 1,
  KIND_EXPORTED = 2,
  KIND_IMPORTED = 3,
}

export interface InspectPoliciesResponse_Constant {
  name: string;
  value: any | undefined;
  kind: InspectPoliciesResponse_Constant_Kind;
  source: string;
  used: boolean;
}

export enum InspectPoliciesResponse_Constant_Kind {
  KIND_UNSPECIFIED = 0,
  KIND_EXPORTED = 1,
  KIND_IMPORTED = 2,
  KIND_LOCAL = 3,
  KIND_UNDEFINED = 4,
  KIND_UNKNOWN = 5,
}

export interface InspectPoliciesResponse_Variable {
  name: string;
  value: string;
  kind: InspectPoliciesResponse_Variable_Kind;
  source: string;
  used: boolean;
}

export enum InspectPoliciesResponse_Variable_Kind {
  KIND_UNSPECIFIED = 0,
  KIND_EXPORTED = 1,
  KIND_IMPORTED = 2,
  KIND_LOCAL = 3,
  KIND_UNDEFINED = 4,
  KIND_UNKNOWN = 5,
}

export interface InspectPoliciesResponse_Result {
  actions: string[];
  variables: InspectPoliciesResponse_Variable[];
  policyId: string;
  derivedRoles: InspectPoliciesResponse_DerivedRole[];
  attributes: InspectPoliciesResponse_Attribute[];
  constants: InspectPoliciesResponse_Constant[];
}

export interface InspectPoliciesResponse_ResultsEntry {
  key: string;
  value: InspectPoliciesResponse_Result | undefined;
}

export interface AddOrUpdateSchemaResponse {}

export interface ListSchemasResponse {
  schemaIds: string[];
}

export interface GetSchemaResponse {
  schemas: Schema[];
}

export interface DeleteSchemaResponse {
  deletedSchemas: number;
}

export interface ReloadStoreResponse {}

function createBasePlanResourcesResponse(): PlanResourcesResponse {
  return {
    requestId: "",
    action: "",
    resourceKind: "",
    policyVersion: "",
    filter: undefined,
    meta: undefined,
    validationErrors: [],
    cerbosCallId: "",
  };
}

export const PlanResourcesResponse: MessageFns<PlanResourcesResponse> = {
  encode(
    message: PlanResourcesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.action !== "") {
      writer.uint32(18).string(message.action);
    }
    if (message.resourceKind !== "") {
      writer.uint32(26).string(message.resourceKind);
    }
    if (message.policyVersion !== "") {
      writer.uint32(34).string(message.policyVersion);
    }
    if (message.filter !== undefined) {
      PlanResourcesFilter.encode(
        message.filter,
        writer.uint32(42).fork(),
      ).join();
    }
    if (message.meta !== undefined) {
      PlanResourcesResponse_Meta.encode(
        message.meta,
        writer.uint32(50).fork(),
      ).join();
    }
    for (const v of message.validationErrors) {
      ValidationError.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.cerbosCallId !== "") {
      writer.uint32(66).string(message.cerbosCallId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PlanResourcesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlanResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.resourceKind = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.policyVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.filter = PlanResourcesFilter.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.meta = PlanResourcesResponse_Meta.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.validationErrors.push(
            ValidationError.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.cerbosCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBasePlanResourcesResponse_Meta(): PlanResourcesResponse_Meta {
  return { filterDebug: "", matchedScope: "" };
}

export const PlanResourcesResponse_Meta: MessageFns<PlanResourcesResponse_Meta> =
  {
    encode(
      message: PlanResourcesResponse_Meta,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.filterDebug !== "") {
        writer.uint32(10).string(message.filterDebug);
      }
      if (message.matchedScope !== "") {
        writer.uint32(18).string(message.matchedScope);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): PlanResourcesResponse_Meta {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBasePlanResourcesResponse_Meta();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.filterDebug = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.matchedScope = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse(): CheckResourceSetResponse {
  return { requestId: "", resourceInstances: {}, meta: undefined };
}

export const CheckResourceSetResponse: MessageFns<CheckResourceSetResponse> = {
  encode(
    message: CheckResourceSetResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    Object.entries(message.resourceInstances).forEach(([key, value]) => {
      CheckResourceSetResponse_ResourceInstancesEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    if (message.meta !== undefined) {
      CheckResourceSetResponse_Meta.encode(
        message.meta,
        writer.uint32(26).fork(),
      ).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CheckResourceSetResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckResourceSetResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = CheckResourceSetResponse_ResourceInstancesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.resourceInstances[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.meta = CheckResourceSetResponse_Meta.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckResourceSetResponse_ActionEffectMap(): CheckResourceSetResponse_ActionEffectMap {
  return { actions: {}, validationErrors: [] };
}

export const CheckResourceSetResponse_ActionEffectMap: MessageFns<CheckResourceSetResponse_ActionEffectMap> =
  {
    encode(
      message: CheckResourceSetResponse_ActionEffectMap,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      Object.entries(message.actions).forEach(([key, value]) => {
        CheckResourceSetResponse_ActionEffectMap_ActionsEntry.encode(
          { key: key as any, value },
          writer.uint32(10).fork(),
        ).join();
      });
      for (const v of message.validationErrors) {
        ValidationError.encode(v!, writer.uint32(18).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_ActionEffectMap {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourceSetResponse_ActionEffectMap();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const entry1 =
              CheckResourceSetResponse_ActionEffectMap_ActionsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry1.value !== undefined) {
              message.actions[entry1.key] = entry1.value;
            }
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.validationErrors.push(
              ValidationError.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse_ActionEffectMap_ActionsEntry(): CheckResourceSetResponse_ActionEffectMap_ActionsEntry {
  return { key: "", value: 0 };
}

export const CheckResourceSetResponse_ActionEffectMap_ActionsEntry: MessageFns<CheckResourceSetResponse_ActionEffectMap_ActionsEntry> =
  {
    encode(
      message: CheckResourceSetResponse_ActionEffectMap_ActionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).int32(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_ActionEffectMap_ActionsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourceSetResponse_ActionEffectMap_ActionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse_Meta(): CheckResourceSetResponse_Meta {
  return { resourceInstances: {} };
}

export const CheckResourceSetResponse_Meta: MessageFns<CheckResourceSetResponse_Meta> =
  {
    encode(
      message: CheckResourceSetResponse_Meta,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      Object.entries(message.resourceInstances).forEach(([key, value]) => {
        CheckResourceSetResponse_Meta_ResourceInstancesEntry.encode(
          { key: key as any, value },
          writer.uint32(10).fork(),
        ).join();
      });
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_Meta {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourceSetResponse_Meta();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const entry1 =
              CheckResourceSetResponse_Meta_ResourceInstancesEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry1.value !== undefined) {
              message.resourceInstances[entry1.key] = entry1.value;
            }
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse_Meta_EffectMeta(): CheckResourceSetResponse_Meta_EffectMeta {
  return { matchedPolicy: "", matchedScope: "" };
}

export const CheckResourceSetResponse_Meta_EffectMeta: MessageFns<CheckResourceSetResponse_Meta_EffectMeta> =
  {
    encode(
      message: CheckResourceSetResponse_Meta_EffectMeta,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.matchedPolicy !== "") {
        writer.uint32(10).string(message.matchedPolicy);
      }
      if (message.matchedScope !== "") {
        writer.uint32(18).string(message.matchedScope);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_Meta_EffectMeta {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourceSetResponse_Meta_EffectMeta();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.matchedPolicy = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.matchedScope = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse_Meta_ActionMeta(): CheckResourceSetResponse_Meta_ActionMeta {
  return { actions: {}, effectiveDerivedRoles: [] };
}

export const CheckResourceSetResponse_Meta_ActionMeta: MessageFns<CheckResourceSetResponse_Meta_ActionMeta> =
  {
    encode(
      message: CheckResourceSetResponse_Meta_ActionMeta,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      Object.entries(message.actions).forEach(([key, value]) => {
        CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry.encode(
          { key: key as any, value },
          writer.uint32(10).fork(),
        ).join();
      });
      for (const v of message.effectiveDerivedRoles) {
        writer.uint32(18).string(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_Meta_ActionMeta {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourceSetResponse_Meta_ActionMeta();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const entry1 =
              CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry1.value !== undefined) {
              message.actions[entry1.key] = entry1.value;
            }
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.effectiveDerivedRoles.push(reader.string());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse_Meta_ActionMeta_ActionsEntry(): CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry {
  return { key: "", value: undefined };
}

export const CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry: MessageFns<CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry> =
  {
    encode(
      message: CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        CheckResourceSetResponse_Meta_EffectMeta.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_Meta_ActionMeta_ActionsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourceSetResponse_Meta_ActionMeta_ActionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = CheckResourceSetResponse_Meta_EffectMeta.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse_Meta_ResourceInstancesEntry(): CheckResourceSetResponse_Meta_ResourceInstancesEntry {
  return { key: "", value: undefined };
}

export const CheckResourceSetResponse_Meta_ResourceInstancesEntry: MessageFns<CheckResourceSetResponse_Meta_ResourceInstancesEntry> =
  {
    encode(
      message: CheckResourceSetResponse_Meta_ResourceInstancesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        CheckResourceSetResponse_Meta_ActionMeta.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_Meta_ResourceInstancesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourceSetResponse_Meta_ResourceInstancesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = CheckResourceSetResponse_Meta_ActionMeta.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceSetResponse_ResourceInstancesEntry(): CheckResourceSetResponse_ResourceInstancesEntry {
  return { key: "", value: undefined };
}

export const CheckResourceSetResponse_ResourceInstancesEntry: MessageFns<CheckResourceSetResponse_ResourceInstancesEntry> =
  {
    encode(
      message: CheckResourceSetResponse_ResourceInstancesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        CheckResourceSetResponse_ActionEffectMap.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceSetResponse_ResourceInstancesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourceSetResponse_ResourceInstancesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = CheckResourceSetResponse_ActionEffectMap.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceBatchResponse(): CheckResourceBatchResponse {
  return { requestId: "", results: [] };
}

export const CheckResourceBatchResponse: MessageFns<CheckResourceBatchResponse> =
  {
    encode(
      message: CheckResourceBatchResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.requestId !== "") {
        writer.uint32(10).string(message.requestId);
      }
      for (const v of message.results) {
        CheckResourceBatchResponse_ActionEffectMap.encode(
          v!,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceBatchResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourceBatchResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.requestId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.results.push(
              CheckResourceBatchResponse_ActionEffectMap.decode(
                reader,
                reader.uint32(),
              ),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceBatchResponse_ActionEffectMap(): CheckResourceBatchResponse_ActionEffectMap {
  return { resourceId: "", actions: {}, validationErrors: [] };
}

export const CheckResourceBatchResponse_ActionEffectMap: MessageFns<CheckResourceBatchResponse_ActionEffectMap> =
  {
    encode(
      message: CheckResourceBatchResponse_ActionEffectMap,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.resourceId !== "") {
        writer.uint32(10).string(message.resourceId);
      }
      Object.entries(message.actions).forEach(([key, value]) => {
        CheckResourceBatchResponse_ActionEffectMap_ActionsEntry.encode(
          { key: key as any, value },
          writer.uint32(18).fork(),
        ).join();
      });
      for (const v of message.validationErrors) {
        ValidationError.encode(v!, writer.uint32(26).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceBatchResponse_ActionEffectMap {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourceBatchResponse_ActionEffectMap();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.resourceId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            const entry2 =
              CheckResourceBatchResponse_ActionEffectMap_ActionsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry2.value !== undefined) {
              message.actions[entry2.key] = entry2.value;
            }
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.validationErrors.push(
              ValidationError.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourceBatchResponse_ActionEffectMap_ActionsEntry(): CheckResourceBatchResponse_ActionEffectMap_ActionsEntry {
  return { key: "", value: 0 };
}

export const CheckResourceBatchResponse_ActionEffectMap_ActionsEntry: MessageFns<CheckResourceBatchResponse_ActionEffectMap_ActionsEntry> =
  {
    encode(
      message: CheckResourceBatchResponse_ActionEffectMap_ActionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).int32(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourceBatchResponse_ActionEffectMap_ActionsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourceBatchResponse_ActionEffectMap_ActionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourcesResponse(): CheckResourcesResponse {
  return { requestId: "", results: [], cerbosCallId: "" };
}

export const CheckResourcesResponse: MessageFns<CheckResourcesResponse> = {
  encode(
    message: CheckResourcesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    for (const v of message.results) {
      CheckResourcesResponse_ResultEntry.encode(
        v!,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.cerbosCallId !== "") {
      writer.uint32(26).string(message.cerbosCallId);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): CheckResourcesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckResourcesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.results.push(
            CheckResourcesResponse_ResultEntry.decode(reader, reader.uint32()),
          );
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.cerbosCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseCheckResourcesResponse_ResultEntry(): CheckResourcesResponse_ResultEntry {
  return {
    resource: undefined,
    actions: {},
    validationErrors: [],
    meta: undefined,
    outputs: [],
  };
}

export const CheckResourcesResponse_ResultEntry: MessageFns<CheckResourcesResponse_ResultEntry> =
  {
    encode(
      message: CheckResourcesResponse_ResultEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.resource !== undefined) {
        CheckResourcesResponse_ResultEntry_Resource.encode(
          message.resource,
          writer.uint32(10).fork(),
        ).join();
      }
      Object.entries(message.actions).forEach(([key, value]) => {
        CheckResourcesResponse_ResultEntry_ActionsEntry.encode(
          { key: key as any, value },
          writer.uint32(18).fork(),
        ).join();
      });
      for (const v of message.validationErrors) {
        ValidationError.encode(v!, writer.uint32(26).fork()).join();
      }
      if (message.meta !== undefined) {
        CheckResourcesResponse_ResultEntry_Meta.encode(
          message.meta,
          writer.uint32(34).fork(),
        ).join();
      }
      for (const v of message.outputs) {
        OutputEntry.encode(v!, writer.uint32(42).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourcesResponse_ResultEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourcesResponse_ResultEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.resource =
              CheckResourcesResponse_ResultEntry_Resource.decode(
                reader,
                reader.uint32(),
              );
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            const entry2 =
              CheckResourcesResponse_ResultEntry_ActionsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry2.value !== undefined) {
              message.actions[entry2.key] = entry2.value;
            }
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.validationErrors.push(
              ValidationError.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.meta = CheckResourcesResponse_ResultEntry_Meta.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.outputs.push(OutputEntry.decode(reader, reader.uint32()));
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourcesResponse_ResultEntry_Resource(): CheckResourcesResponse_ResultEntry_Resource {
  return { id: "", kind: "", policyVersion: "", scope: "" };
}

export const CheckResourcesResponse_ResultEntry_Resource: MessageFns<CheckResourcesResponse_ResultEntry_Resource> =
  {
    encode(
      message: CheckResourcesResponse_ResultEntry_Resource,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.id !== "") {
        writer.uint32(10).string(message.id);
      }
      if (message.kind !== "") {
        writer.uint32(18).string(message.kind);
      }
      if (message.policyVersion !== "") {
        writer.uint32(26).string(message.policyVersion);
      }
      if (message.scope !== "") {
        writer.uint32(34).string(message.scope);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourcesResponse_ResultEntry_Resource {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourcesResponse_ResultEntry_Resource();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.id = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.kind = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.policyVersion = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.scope = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourcesResponse_ResultEntry_Meta(): CheckResourcesResponse_ResultEntry_Meta {
  return { actions: {}, effectiveDerivedRoles: [] };
}

export const CheckResourcesResponse_ResultEntry_Meta: MessageFns<CheckResourcesResponse_ResultEntry_Meta> =
  {
    encode(
      message: CheckResourcesResponse_ResultEntry_Meta,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      Object.entries(message.actions).forEach(([key, value]) => {
        CheckResourcesResponse_ResultEntry_Meta_ActionsEntry.encode(
          { key: key as any, value },
          writer.uint32(10).fork(),
        ).join();
      });
      for (const v of message.effectiveDerivedRoles) {
        writer.uint32(18).string(v!);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourcesResponse_ResultEntry_Meta {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseCheckResourcesResponse_ResultEntry_Meta();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            const entry1 =
              CheckResourcesResponse_ResultEntry_Meta_ActionsEntry.decode(
                reader,
                reader.uint32(),
              );
            if (entry1.value !== undefined) {
              message.actions[entry1.key] = entry1.value;
            }
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.effectiveDerivedRoles.push(reader.string());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourcesResponse_ResultEntry_Meta_EffectMeta(): CheckResourcesResponse_ResultEntry_Meta_EffectMeta {
  return { matchedPolicy: "", matchedScope: "" };
}

export const CheckResourcesResponse_ResultEntry_Meta_EffectMeta: MessageFns<CheckResourcesResponse_ResultEntry_Meta_EffectMeta> =
  {
    encode(
      message: CheckResourcesResponse_ResultEntry_Meta_EffectMeta,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.matchedPolicy !== "") {
        writer.uint32(10).string(message.matchedPolicy);
      }
      if (message.matchedScope !== "") {
        writer.uint32(18).string(message.matchedScope);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourcesResponse_ResultEntry_Meta_EffectMeta {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourcesResponse_ResultEntry_Meta_EffectMeta();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.matchedPolicy = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.matchedScope = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourcesResponse_ResultEntry_Meta_ActionsEntry(): CheckResourcesResponse_ResultEntry_Meta_ActionsEntry {
  return { key: "", value: undefined };
}

export const CheckResourcesResponse_ResultEntry_Meta_ActionsEntry: MessageFns<CheckResourcesResponse_ResultEntry_Meta_ActionsEntry> =
  {
    encode(
      message: CheckResourcesResponse_ResultEntry_Meta_ActionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        CheckResourcesResponse_ResultEntry_Meta_EffectMeta.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourcesResponse_ResultEntry_Meta_ActionsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourcesResponse_ResultEntry_Meta_ActionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value =
              CheckResourcesResponse_ResultEntry_Meta_EffectMeta.decode(
                reader,
                reader.uint32(),
              );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseCheckResourcesResponse_ResultEntry_ActionsEntry(): CheckResourcesResponse_ResultEntry_ActionsEntry {
  return { key: "", value: 0 };
}

export const CheckResourcesResponse_ResultEntry_ActionsEntry: MessageFns<CheckResourcesResponse_ResultEntry_ActionsEntry> =
  {
    encode(
      message: CheckResourcesResponse_ResultEntry_ActionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== 0) {
        writer.uint32(16).int32(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): CheckResourcesResponse_ResultEntry_ActionsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message =
        createBaseCheckResourcesResponse_ResultEntry_ActionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.value = reader.int32() as any;
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseAddOrUpdatePolicyResponse(): AddOrUpdatePolicyResponse {
  return { success: undefined };
}

export const AddOrUpdatePolicyResponse: MessageFns<AddOrUpdatePolicyResponse> =
  {
    encode(
      message: AddOrUpdatePolicyResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.success !== undefined) {
        Empty.encode(message.success, writer.uint32(10).fork()).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): AddOrUpdatePolicyResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAddOrUpdatePolicyResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.success = Empty.decode(reader, reader.uint32());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseListAuditLogEntriesResponse(): ListAuditLogEntriesResponse {
  return { entry: undefined };
}

export const ListAuditLogEntriesResponse: MessageFns<ListAuditLogEntriesResponse> =
  {
    encode(
      message: ListAuditLogEntriesResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      switch (message.entry?.$case) {
        case "accessLogEntry":
          AccessLogEntry.encode(
            message.entry.accessLogEntry,
            writer.uint32(10).fork(),
          ).join();
          break;
        case "decisionLogEntry":
          DecisionLogEntry.encode(
            message.entry.decisionLogEntry,
            writer.uint32(18).fork(),
          ).join();
          break;
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ListAuditLogEntriesResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseListAuditLogEntriesResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.entry = {
              $case: "accessLogEntry",
              accessLogEntry: AccessLogEntry.decode(reader, reader.uint32()),
            };
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.entry = {
              $case: "decisionLogEntry",
              decisionLogEntry: DecisionLogEntry.decode(
                reader,
                reader.uint32(),
              ),
            };
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseServerInfoResponse(): ServerInfoResponse {
  return { version: "", commit: "", buildDate: "" };
}

export const ServerInfoResponse: MessageFns<ServerInfoResponse> = {
  encode(
    message: ServerInfoResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.version !== "") {
      writer.uint32(10).string(message.version);
    }
    if (message.commit !== "") {
      writer.uint32(18).string(message.commit);
    }
    if (message.buildDate !== "") {
      writer.uint32(26).string(message.buildDate);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ServerInfoResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.commit = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buildDate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseListPoliciesResponse(): ListPoliciesResponse {
  return { policyIds: [] };
}

export const ListPoliciesResponse: MessageFns<ListPoliciesResponse> = {
  encode(
    message: ListPoliciesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.policyIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ListPoliciesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policyIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetPolicyResponse(): GetPolicyResponse {
  return { policies: [] };
}

export const GetPolicyResponse: MessageFns<GetPolicyResponse> = {
  encode(
    message: GetPolicyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.policies) {
      Policy.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetPolicyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policies.push(Policy.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDisablePolicyResponse(): DisablePolicyResponse {
  return { disabledPolicies: 0 };
}

export const DisablePolicyResponse: MessageFns<DisablePolicyResponse> = {
  encode(
    message: DisablePolicyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.disabledPolicies !== 0) {
      writer.uint32(8).uint32(message.disabledPolicies);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DisablePolicyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisablePolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.disabledPolicies = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseEnablePolicyResponse(): EnablePolicyResponse {
  return { enabledPolicies: 0 };
}

export const EnablePolicyResponse: MessageFns<EnablePolicyResponse> = {
  encode(
    message: EnablePolicyResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.enabledPolicies !== 0) {
      writer.uint32(8).uint32(message.enabledPolicies);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): EnablePolicyResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnablePolicyResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabledPolicies = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseInspectPoliciesResponse(): InspectPoliciesResponse {
  return { results: {} };
}

export const InspectPoliciesResponse: MessageFns<InspectPoliciesResponse> = {
  encode(
    message: InspectPoliciesResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.results).forEach(([key, value]) => {
      InspectPoliciesResponse_ResultsEntry.encode(
        { key: key as any, value },
        writer.uint32(10).fork(),
      ).join();
    });
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): InspectPoliciesResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInspectPoliciesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = InspectPoliciesResponse_ResultsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.results[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseInspectPoliciesResponse_Attribute(): InspectPoliciesResponse_Attribute {
  return { kind: 0, name: "" };
}

export const InspectPoliciesResponse_Attribute: MessageFns<InspectPoliciesResponse_Attribute> =
  {
    encode(
      message: InspectPoliciesResponse_Attribute,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.kind !== 0) {
        writer.uint32(8).int32(message.kind);
      }
      if (message.name !== "") {
        writer.uint32(18).string(message.name);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InspectPoliciesResponse_Attribute {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInspectPoliciesResponse_Attribute();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 8) {
              break;
            }

            message.kind = reader.int32() as any;
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.name = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseInspectPoliciesResponse_DerivedRole(): InspectPoliciesResponse_DerivedRole {
  return { name: "", kind: 0, source: "" };
}

export const InspectPoliciesResponse_DerivedRole: MessageFns<InspectPoliciesResponse_DerivedRole> =
  {
    encode(
      message: InspectPoliciesResponse_DerivedRole,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.kind !== 0) {
        writer.uint32(16).int32(message.kind);
      }
      if (message.source !== "") {
        writer.uint32(26).string(message.source);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InspectPoliciesResponse_DerivedRole {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInspectPoliciesResponse_DerivedRole();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.kind = reader.int32() as any;
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.source = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseInspectPoliciesResponse_Constant(): InspectPoliciesResponse_Constant {
  return { name: "", value: undefined, kind: 0, source: "", used: false };
}

export const InspectPoliciesResponse_Constant: MessageFns<InspectPoliciesResponse_Constant> =
  {
    encode(
      message: InspectPoliciesResponse_Constant,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.value !== undefined) {
        Value.encode(
          Value.wrap(message.value),
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.kind !== 0) {
        writer.uint32(24).int32(message.kind);
      }
      if (message.source !== "") {
        writer.uint32(34).string(message.source);
      }
      if (message.used !== false) {
        writer.uint32(40).bool(message.used);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InspectPoliciesResponse_Constant {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInspectPoliciesResponse_Constant();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.kind = reader.int32() as any;
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.source = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.used = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseInspectPoliciesResponse_Variable(): InspectPoliciesResponse_Variable {
  return { name: "", value: "", kind: 0, source: "", used: false };
}

export const InspectPoliciesResponse_Variable: MessageFns<InspectPoliciesResponse_Variable> =
  {
    encode(
      message: InspectPoliciesResponse_Variable,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.name !== "") {
        writer.uint32(10).string(message.name);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      if (message.kind !== 0) {
        writer.uint32(24).int32(message.kind);
      }
      if (message.source !== "") {
        writer.uint32(34).string(message.source);
      }
      if (message.used !== false) {
        writer.uint32(40).bool(message.used);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InspectPoliciesResponse_Variable {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInspectPoliciesResponse_Variable();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.name = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.kind = reader.int32() as any;
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.source = reader.string();
            continue;
          }
          case 5: {
            if (tag !== 40) {
              break;
            }

            message.used = reader.bool();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseInspectPoliciesResponse_Result(): InspectPoliciesResponse_Result {
  return {
    actions: [],
    variables: [],
    policyId: "",
    derivedRoles: [],
    attributes: [],
    constants: [],
  };
}

export const InspectPoliciesResponse_Result: MessageFns<InspectPoliciesResponse_Result> =
  {
    encode(
      message: InspectPoliciesResponse_Result,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      for (const v of message.actions) {
        writer.uint32(10).string(v!);
      }
      for (const v of message.variables) {
        InspectPoliciesResponse_Variable.encode(
          v!,
          writer.uint32(18).fork(),
        ).join();
      }
      if (message.policyId !== "") {
        writer.uint32(26).string(message.policyId);
      }
      for (const v of message.derivedRoles) {
        InspectPoliciesResponse_DerivedRole.encode(
          v!,
          writer.uint32(34).fork(),
        ).join();
      }
      for (const v of message.attributes) {
        InspectPoliciesResponse_Attribute.encode(
          v!,
          writer.uint32(42).fork(),
        ).join();
      }
      for (const v of message.constants) {
        InspectPoliciesResponse_Constant.encode(
          v!,
          writer.uint32(50).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InspectPoliciesResponse_Result {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInspectPoliciesResponse_Result();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.actions.push(reader.string());
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.variables.push(
              InspectPoliciesResponse_Variable.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 3: {
            if (tag !== 26) {
              break;
            }

            message.policyId = reader.string();
            continue;
          }
          case 4: {
            if (tag !== 34) {
              break;
            }

            message.derivedRoles.push(
              InspectPoliciesResponse_DerivedRole.decode(
                reader,
                reader.uint32(),
              ),
            );
            continue;
          }
          case 5: {
            if (tag !== 42) {
              break;
            }

            message.attributes.push(
              InspectPoliciesResponse_Attribute.decode(reader, reader.uint32()),
            );
            continue;
          }
          case 6: {
            if (tag !== 50) {
              break;
            }

            message.constants.push(
              InspectPoliciesResponse_Constant.decode(reader, reader.uint32()),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseInspectPoliciesResponse_ResultsEntry(): InspectPoliciesResponse_ResultsEntry {
  return { key: "", value: undefined };
}

export const InspectPoliciesResponse_ResultsEntry: MessageFns<InspectPoliciesResponse_ResultsEntry> =
  {
    encode(
      message: InspectPoliciesResponse_ResultsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        InspectPoliciesResponse_Result.encode(
          message.value,
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): InspectPoliciesResponse_ResultsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseInspectPoliciesResponse_ResultsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = InspectPoliciesResponse_Result.decode(
              reader,
              reader.uint32(),
            );
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseAddOrUpdateSchemaResponse(): AddOrUpdateSchemaResponse {
  return {};
}

export const AddOrUpdateSchemaResponse: MessageFns<AddOrUpdateSchemaResponse> =
  {
    encode(
      _: AddOrUpdateSchemaResponse,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): AddOrUpdateSchemaResponse {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseAddOrUpdateSchemaResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },
  };

function createBaseListSchemasResponse(): ListSchemasResponse {
  return { schemaIds: [] };
}

export const ListSchemasResponse: MessageFns<ListSchemasResponse> = {
  encode(
    message: ListSchemasResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.schemaIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ListSchemasResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSchemasResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseGetSchemaResponse(): GetSchemaResponse {
  return { schemas: [] };
}

export const GetSchemaResponse: MessageFns<GetSchemaResponse> = {
  encode(
    message: GetSchemaResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.schemas) {
      Schema.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSchemaResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemas.push(Schema.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteSchemaResponse(): DeleteSchemaResponse {
  return { deletedSchemas: 0 };
}

export const DeleteSchemaResponse: MessageFns<DeleteSchemaResponse> = {
  encode(
    message: DeleteSchemaResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.deletedSchemas !== 0) {
      writer.uint32(8).uint32(message.deletedSchemas);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): DeleteSchemaResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSchemaResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deletedSchemas = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

function createBaseReloadStoreResponse(): ReloadStoreResponse {
  return {};
}

export const ReloadStoreResponse: MessageFns<ReloadStoreResponse> = {
  encode(
    _: ReloadStoreResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): ReloadStoreResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReloadStoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
}

// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: openapiv3/OpenAPIv3.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any as Any1 } from "../google/protobuf/any.js";

export const protobufPackage = "openapi.v3";

export interface AdditionalPropertiesItem {
  oneof?:
    | { $case: "schemaOrReference"; schemaOrReference: SchemaOrReference }
    | { $case: "boolean"; boolean: boolean }
    | undefined;
}

export interface Any {
  value: Any1 | undefined;
  yaml: string;
}

export interface DefaultType {
  oneof?:
    | { $case: "number"; number: number }
    | { $case: "boolean"; boolean: boolean }
    | {
        $case: "string";
        string: string;
      }
    | undefined;
}

export interface Discriminator {
  propertyName: string;
  mapping: Strings | undefined;
  specificationExtension: NamedAny[];
}

export interface ExternalDocs {
  description: string;
  url: string;
  specificationExtension: NamedAny[];
}

export interface ItemsItem {
  schemaOrReference: SchemaOrReference[];
}

export interface NamedAny {
  name: string;
  value: Any | undefined;
}

export interface NamedSchemaOrReference {
  name: string;
  value: SchemaOrReference | undefined;
}

export interface NamedString {
  name: string;
  value: string;
}

export interface Properties {
  additionalProperties: NamedSchemaOrReference[];
}

export interface Reference {
  Ref: string;
  summary: string;
  description: string;
}

export interface Schema {
  nullable: boolean;
  discriminator: Discriminator | undefined;
  readOnly: boolean;
  writeOnly: boolean;
  xml: Xml | undefined;
  externalDocs: ExternalDocs | undefined;
  example: Any | undefined;
  deprecated: boolean;
  title: string;
  multipleOf: number;
  maximum: number;
  exclusiveMaximum: boolean;
  minimum: number;
  exclusiveMinimum: boolean;
  maxLength: bigint;
  minLength: bigint;
  pattern: string;
  maxItems: bigint;
  minItems: bigint;
  uniqueItems: boolean;
  maxProperties: bigint;
  minProperties: bigint;
  required: string[];
  enum: Any[];
  type: string;
  allOf: SchemaOrReference[];
  oneOf: SchemaOrReference[];
  anyOf: SchemaOrReference[];
  not: Schema | undefined;
  items: ItemsItem | undefined;
  properties: Properties | undefined;
  additionalProperties: AdditionalPropertiesItem | undefined;
  default: DefaultType | undefined;
  description: string;
  format: string;
  specificationExtension: NamedAny[];
}

export interface SchemaOrReference {
  oneof?:
    | { $case: "schema"; schema: Schema }
    | { $case: "reference"; reference: Reference }
    | undefined;
}

export interface Strings {
  additionalProperties: NamedString[];
}

export interface Xml {
  name: string;
  namespace: string;
  prefix: string;
  attribute: boolean;
  wrapped: boolean;
  specificationExtension: NamedAny[];
}

function createBaseAdditionalPropertiesItem(): AdditionalPropertiesItem {
  return { oneof: undefined };
}

export const AdditionalPropertiesItem: MessageFns<AdditionalPropertiesItem> = {
  encode(
    message: AdditionalPropertiesItem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.oneof?.$case) {
      case "schemaOrReference":
        SchemaOrReference.encode(
          message.oneof.schemaOrReference,
          writer.uint32(10).fork(),
        ).join();
        break;
      case "boolean":
        writer.uint32(16).bool(message.oneof.boolean);
        break;
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): AdditionalPropertiesItem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdditionalPropertiesItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oneof = {
            $case: "schemaOrReference",
            schemaOrReference: SchemaOrReference.decode(
              reader,
              reader.uint32(),
            ),
          };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.oneof = { $case: "boolean", boolean: reader.bool() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: AdditionalPropertiesItem): unknown {
    const obj: any = {};
    if (message.oneof?.$case === "schemaOrReference") {
      obj.schemaOrReference = SchemaOrReference.toJSON(
        message.oneof.schemaOrReference,
      );
    } else if (message.oneof?.$case === "boolean") {
      obj.boolean = message.oneof.boolean;
    }
    return obj;
  },
};

function createBaseAny(): Any {
  return { value: undefined, yaml: "" };
}

export const Any: MessageFns<Any> = {
  encode(
    message: Any,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.value !== undefined) {
      Any1.encode(message.value, writer.uint32(10).fork()).join();
    }
    if (message.yaml !== "") {
      writer.uint32(18).string(message.yaml);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Any {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.value = Any1.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.yaml = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Any): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = Any1.toJSON(message.value);
    }
    if (message.yaml !== "") {
      obj.yaml = message.yaml;
    }
    return obj;
  },
};

function createBaseDefaultType(): DefaultType {
  return { oneof: undefined };
}

export const DefaultType: MessageFns<DefaultType> = {
  encode(
    message: DefaultType,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.oneof?.$case) {
      case "number":
        writer.uint32(9).double(message.oneof.number);
        break;
      case "boolean":
        writer.uint32(16).bool(message.oneof.boolean);
        break;
      case "string":
        writer.uint32(26).string(message.oneof.string);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DefaultType {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDefaultType();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.oneof = { $case: "number", number: reader.double() };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.oneof = { $case: "boolean", boolean: reader.bool() };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oneof = { $case: "string", string: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: DefaultType): unknown {
    const obj: any = {};
    if (message.oneof?.$case === "number") {
      obj.number = message.oneof.number;
    } else if (message.oneof?.$case === "boolean") {
      obj.boolean = message.oneof.boolean;
    } else if (message.oneof?.$case === "string") {
      obj.string = message.oneof.string;
    }
    return obj;
  },
};

function createBaseDiscriminator(): Discriminator {
  return { propertyName: "", mapping: undefined, specificationExtension: [] };
}

export const Discriminator: MessageFns<Discriminator> = {
  encode(
    message: Discriminator,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.propertyName !== "") {
      writer.uint32(10).string(message.propertyName);
    }
    if (message.mapping !== undefined) {
      Strings.encode(message.mapping, writer.uint32(18).fork()).join();
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Discriminator {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscriminator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.propertyName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mapping = Strings.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Discriminator): unknown {
    const obj: any = {};
    if (message.propertyName !== "") {
      obj.propertyName = message.propertyName;
    }
    if (message.mapping !== undefined) {
      obj.mapping = Strings.toJSON(message.mapping);
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map((e) =>
        NamedAny.toJSON(e),
      );
    }
    return obj;
  },
};

function createBaseExternalDocs(): ExternalDocs {
  return { description: "", url: "", specificationExtension: [] };
}

export const ExternalDocs: MessageFns<ExternalDocs> = {
  encode(
    message: ExternalDocs,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExternalDocs {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExternalDocs();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: ExternalDocs): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map((e) =>
        NamedAny.toJSON(e),
      );
    }
    return obj;
  },
};

function createBaseItemsItem(): ItemsItem {
  return { schemaOrReference: [] };
}

export const ItemsItem: MessageFns<ItemsItem> = {
  encode(
    message: ItemsItem,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.schemaOrReference) {
      SchemaOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ItemsItem {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseItemsItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.schemaOrReference.push(
            SchemaOrReference.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: ItemsItem): unknown {
    const obj: any = {};
    if (message.schemaOrReference?.length) {
      obj.schemaOrReference = message.schemaOrReference.map((e) =>
        SchemaOrReference.toJSON(e),
      );
    }
    return obj;
  },
};

function createBaseNamedAny(): NamedAny {
  return { name: "", value: undefined };
}

export const NamedAny: MessageFns<NamedAny> = {
  encode(
    message: NamedAny,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      Any.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedAny {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: NamedAny): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = Any.toJSON(message.value);
    }
    return obj;
  },
};

function createBaseNamedSchemaOrReference(): NamedSchemaOrReference {
  return { name: "", value: undefined };
}

export const NamedSchemaOrReference: MessageFns<NamedSchemaOrReference> = {
  encode(
    message: NamedSchemaOrReference,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== undefined) {
      SchemaOrReference.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): NamedSchemaOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedSchemaOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = SchemaOrReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: NamedSchemaOrReference): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== undefined) {
      obj.value = SchemaOrReference.toJSON(message.value);
    }
    return obj;
  },
};

function createBaseNamedString(): NamedString {
  return { name: "", value: "" };
}

export const NamedString: MessageFns<NamedString> = {
  encode(
    message: NamedString,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NamedString {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNamedString();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: NamedString): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseProperties(): Properties {
  return { additionalProperties: [] };
}

export const Properties: MessageFns<Properties> = {
  encode(
    message: Properties,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedSchemaOrReference.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Properties {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedSchemaOrReference.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Properties): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map((e) =>
        NamedSchemaOrReference.toJSON(e),
      );
    }
    return obj;
  },
};

function createBaseReference(): Reference {
  return { Ref: "", summary: "", description: "" };
}

export const Reference: MessageFns<Reference> = {
  encode(
    message: Reference,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.Ref !== "") {
      writer.uint32(10).string(message.Ref);
    }
    if (message.summary !== "") {
      writer.uint32(18).string(message.summary);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.Ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.summary = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Reference): unknown {
    const obj: any = {};
    if (message.Ref !== "") {
      obj.Ref = message.Ref;
    }
    if (message.summary !== "") {
      obj.summary = message.summary;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },
};

function createBaseSchema(): Schema {
  return {
    nullable: false,
    discriminator: undefined,
    readOnly: false,
    writeOnly: false,
    xml: undefined,
    externalDocs: undefined,
    example: undefined,
    deprecated: false,
    title: "",
    multipleOf: 0,
    maximum: 0,
    exclusiveMaximum: false,
    minimum: 0,
    exclusiveMinimum: false,
    maxLength: 0n,
    minLength: 0n,
    pattern: "",
    maxItems: 0n,
    minItems: 0n,
    uniqueItems: false,
    maxProperties: 0n,
    minProperties: 0n,
    required: [],
    enum: [],
    type: "",
    allOf: [],
    oneOf: [],
    anyOf: [],
    not: undefined,
    items: undefined,
    properties: undefined,
    additionalProperties: undefined,
    default: undefined,
    description: "",
    format: "",
    specificationExtension: [],
  };
}

export const Schema: MessageFns<Schema> = {
  encode(
    message: Schema,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.nullable !== false) {
      writer.uint32(8).bool(message.nullable);
    }
    if (message.discriminator !== undefined) {
      Discriminator.encode(
        message.discriminator,
        writer.uint32(18).fork(),
      ).join();
    }
    if (message.readOnly !== false) {
      writer.uint32(24).bool(message.readOnly);
    }
    if (message.writeOnly !== false) {
      writer.uint32(32).bool(message.writeOnly);
    }
    if (message.xml !== undefined) {
      Xml.encode(message.xml, writer.uint32(42).fork()).join();
    }
    if (message.externalDocs !== undefined) {
      ExternalDocs.encode(
        message.externalDocs,
        writer.uint32(50).fork(),
      ).join();
    }
    if (message.example !== undefined) {
      Any.encode(message.example, writer.uint32(58).fork()).join();
    }
    if (message.deprecated !== false) {
      writer.uint32(64).bool(message.deprecated);
    }
    if (message.title !== "") {
      writer.uint32(74).string(message.title);
    }
    if (message.multipleOf !== 0) {
      writer.uint32(81).double(message.multipleOf);
    }
    if (message.maximum !== 0) {
      writer.uint32(89).double(message.maximum);
    }
    if (message.exclusiveMaximum !== false) {
      writer.uint32(96).bool(message.exclusiveMaximum);
    }
    if (message.minimum !== 0) {
      writer.uint32(105).double(message.minimum);
    }
    if (message.exclusiveMinimum !== false) {
      writer.uint32(112).bool(message.exclusiveMinimum);
    }
    if (message.maxLength !== 0n) {
      if (BigInt.asIntN(64, message.maxLength) !== message.maxLength) {
        throw new globalThis.Error(
          "value provided for field message.maxLength of type int64 too large",
        );
      }
      writer.uint32(120).int64(message.maxLength);
    }
    if (message.minLength !== 0n) {
      if (BigInt.asIntN(64, message.minLength) !== message.minLength) {
        throw new globalThis.Error(
          "value provided for field message.minLength of type int64 too large",
        );
      }
      writer.uint32(128).int64(message.minLength);
    }
    if (message.pattern !== "") {
      writer.uint32(138).string(message.pattern);
    }
    if (message.maxItems !== 0n) {
      if (BigInt.asIntN(64, message.maxItems) !== message.maxItems) {
        throw new globalThis.Error(
          "value provided for field message.maxItems of type int64 too large",
        );
      }
      writer.uint32(144).int64(message.maxItems);
    }
    if (message.minItems !== 0n) {
      if (BigInt.asIntN(64, message.minItems) !== message.minItems) {
        throw new globalThis.Error(
          "value provided for field message.minItems of type int64 too large",
        );
      }
      writer.uint32(152).int64(message.minItems);
    }
    if (message.uniqueItems !== false) {
      writer.uint32(160).bool(message.uniqueItems);
    }
    if (message.maxProperties !== 0n) {
      if (BigInt.asIntN(64, message.maxProperties) !== message.maxProperties) {
        throw new globalThis.Error(
          "value provided for field message.maxProperties of type int64 too large",
        );
      }
      writer.uint32(168).int64(message.maxProperties);
    }
    if (message.minProperties !== 0n) {
      if (BigInt.asIntN(64, message.minProperties) !== message.minProperties) {
        throw new globalThis.Error(
          "value provided for field message.minProperties of type int64 too large",
        );
      }
      writer.uint32(176).int64(message.minProperties);
    }
    for (const v of message.required) {
      writer.uint32(186).string(v!);
    }
    for (const v of message.enum) {
      Any.encode(v!, writer.uint32(194).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(202).string(message.type);
    }
    for (const v of message.allOf) {
      SchemaOrReference.encode(v!, writer.uint32(210).fork()).join();
    }
    for (const v of message.oneOf) {
      SchemaOrReference.encode(v!, writer.uint32(218).fork()).join();
    }
    for (const v of message.anyOf) {
      SchemaOrReference.encode(v!, writer.uint32(226).fork()).join();
    }
    if (message.not !== undefined) {
      Schema.encode(message.not, writer.uint32(234).fork()).join();
    }
    if (message.items !== undefined) {
      ItemsItem.encode(message.items, writer.uint32(242).fork()).join();
    }
    if (message.properties !== undefined) {
      Properties.encode(message.properties, writer.uint32(250).fork()).join();
    }
    if (message.additionalProperties !== undefined) {
      AdditionalPropertiesItem.encode(
        message.additionalProperties,
        writer.uint32(258).fork(),
      ).join();
    }
    if (message.default !== undefined) {
      DefaultType.encode(message.default, writer.uint32(266).fork()).join();
    }
    if (message.description !== "") {
      writer.uint32(274).string(message.description);
    }
    if (message.format !== "") {
      writer.uint32(282).string(message.format);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(290).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schema {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nullable = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.discriminator = Discriminator.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.readOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.writeOnly = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.xml = Xml.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.externalDocs = ExternalDocs.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.example = Any.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 81) {
            break;
          }

          message.multipleOf = reader.double();
          continue;
        }
        case 11: {
          if (tag !== 89) {
            break;
          }

          message.maximum = reader.double();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.exclusiveMaximum = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 105) {
            break;
          }

          message.minimum = reader.double();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.exclusiveMinimum = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.maxLength = reader.int64() as bigint;
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.minLength = reader.int64() as bigint;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.maxItems = reader.int64() as bigint;
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.minItems = reader.int64() as bigint;
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }

          message.uniqueItems = reader.bool();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.maxProperties = reader.int64() as bigint;
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.minProperties = reader.int64() as bigint;
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.required.push(reader.string());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.enum.push(Any.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.allOf.push(SchemaOrReference.decode(reader, reader.uint32()));
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.oneOf.push(SchemaOrReference.decode(reader, reader.uint32()));
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.anyOf.push(SchemaOrReference.decode(reader, reader.uint32()));
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.not = Schema.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.items = ItemsItem.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.properties = Properties.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.additionalProperties = AdditionalPropertiesItem.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.default = DefaultType.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Schema): unknown {
    const obj: any = {};
    if (message.nullable !== false) {
      obj.nullable = message.nullable;
    }
    if (message.discriminator !== undefined) {
      obj.discriminator = Discriminator.toJSON(message.discriminator);
    }
    if (message.readOnly !== false) {
      obj.readOnly = message.readOnly;
    }
    if (message.writeOnly !== false) {
      obj.writeOnly = message.writeOnly;
    }
    if (message.xml !== undefined) {
      obj.xml = Xml.toJSON(message.xml);
    }
    if (message.externalDocs !== undefined) {
      obj.externalDocs = ExternalDocs.toJSON(message.externalDocs);
    }
    if (message.example !== undefined) {
      obj.example = Any.toJSON(message.example);
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.multipleOf !== 0) {
      obj.multipleOf = message.multipleOf;
    }
    if (message.maximum !== 0) {
      obj.maximum = message.maximum;
    }
    if (message.exclusiveMaximum !== false) {
      obj.exclusiveMaximum = message.exclusiveMaximum;
    }
    if (message.minimum !== 0) {
      obj.minimum = message.minimum;
    }
    if (message.exclusiveMinimum !== false) {
      obj.exclusiveMinimum = message.exclusiveMinimum;
    }
    if (message.maxLength !== 0n) {
      obj.maxLength = message.maxLength.toString();
    }
    if (message.minLength !== 0n) {
      obj.minLength = message.minLength.toString();
    }
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.maxItems !== 0n) {
      obj.maxItems = message.maxItems.toString();
    }
    if (message.minItems !== 0n) {
      obj.minItems = message.minItems.toString();
    }
    if (message.uniqueItems !== false) {
      obj.uniqueItems = message.uniqueItems;
    }
    if (message.maxProperties !== 0n) {
      obj.maxProperties = message.maxProperties.toString();
    }
    if (message.minProperties !== 0n) {
      obj.minProperties = message.minProperties.toString();
    }
    if (message.required?.length) {
      obj.required = message.required;
    }
    if (message.enum?.length) {
      obj.enum = message.enum.map((e) => Any.toJSON(e));
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.allOf?.length) {
      obj.allOf = message.allOf.map((e) => SchemaOrReference.toJSON(e));
    }
    if (message.oneOf?.length) {
      obj.oneOf = message.oneOf.map((e) => SchemaOrReference.toJSON(e));
    }
    if (message.anyOf?.length) {
      obj.anyOf = message.anyOf.map((e) => SchemaOrReference.toJSON(e));
    }
    if (message.not !== undefined) {
      obj.not = Schema.toJSON(message.not);
    }
    if (message.items !== undefined) {
      obj.items = ItemsItem.toJSON(message.items);
    }
    if (message.properties !== undefined) {
      obj.properties = Properties.toJSON(message.properties);
    }
    if (message.additionalProperties !== undefined) {
      obj.additionalProperties = AdditionalPropertiesItem.toJSON(
        message.additionalProperties,
      );
    }
    if (message.default !== undefined) {
      obj.default = DefaultType.toJSON(message.default);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map((e) =>
        NamedAny.toJSON(e),
      );
    }
    return obj;
  },
};

function createBaseSchemaOrReference(): SchemaOrReference {
  return { oneof: undefined };
}

export const SchemaOrReference: MessageFns<SchemaOrReference> = {
  encode(
    message: SchemaOrReference,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.oneof?.$case) {
      case "schema":
        Schema.encode(message.oneof.schema, writer.uint32(10).fork()).join();
        break;
      case "reference":
        Reference.encode(
          message.oneof.reference,
          writer.uint32(18).fork(),
        ).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchemaOrReference {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemaOrReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oneof = {
            $case: "schema",
            schema: Schema.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oneof = {
            $case: "reference",
            reference: Reference.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: SchemaOrReference): unknown {
    const obj: any = {};
    if (message.oneof?.$case === "schema") {
      obj.schema = Schema.toJSON(message.oneof.schema);
    } else if (message.oneof?.$case === "reference") {
      obj.reference = Reference.toJSON(message.oneof.reference);
    }
    return obj;
  },
};

function createBaseStrings(): Strings {
  return { additionalProperties: [] };
}

export const Strings: MessageFns<Strings> = {
  encode(
    message: Strings,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.additionalProperties) {
      NamedString.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Strings {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStrings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.additionalProperties.push(
            NamedString.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Strings): unknown {
    const obj: any = {};
    if (message.additionalProperties?.length) {
      obj.additionalProperties = message.additionalProperties.map((e) =>
        NamedString.toJSON(e),
      );
    }
    return obj;
  },
};

function createBaseXml(): Xml {
  return {
    name: "",
    namespace: "",
    prefix: "",
    attribute: false,
    wrapped: false,
    specificationExtension: [],
  };
}

export const Xml: MessageFns<Xml> = {
  encode(
    message: Xml,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.namespace !== "") {
      writer.uint32(18).string(message.namespace);
    }
    if (message.prefix !== "") {
      writer.uint32(26).string(message.prefix);
    }
    if (message.attribute !== false) {
      writer.uint32(32).bool(message.attribute);
    }
    if (message.wrapped !== false) {
      writer.uint32(40).bool(message.wrapped);
    }
    for (const v of message.specificationExtension) {
      NamedAny.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Xml {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseXml();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.namespace = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.attribute = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.wrapped = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.specificationExtension.push(
            NamedAny.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  toJSON(message: Xml): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.namespace !== "") {
      obj.namespace = message.namespace;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.attribute !== false) {
      obj.attribute = message.attribute;
    }
    if (message.wrapped !== false) {
      obj.wrapped = message.wrapped;
    }
    if (message.specificationExtension?.length) {
      obj.specificationExtension = message.specificationExtension.map((e) =>
        NamedAny.toJSON(e),
      );
    }
    return obj;
  },
};

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  toJSON(message: T): unknown;
}

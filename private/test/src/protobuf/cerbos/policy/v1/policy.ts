// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// source: cerbos/policy/v1/policy.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Value } from "../../../google/protobuf/struct";
import { UInt64Value } from "../../../google/protobuf/wrappers";
import { Effect, effectFromJSON, effectToJSON } from "../../effect/v1/effect";

export const protobufPackage = "cerbos.policy.v1";

export enum ScopePermissions {
  SCOPE_PERMISSIONS_UNSPECIFIED = 0,
  SCOPE_PERMISSIONS_OVERRIDE_PARENT = 1,
  SCOPE_PERMISSIONS_REQUIRE_PARENTAL_CONSENT_FOR_ALLOWS = 2,
}

export function scopePermissionsFromJSON(object: any): ScopePermissions {
  switch (object) {
    case 0:
    case "SCOPE_PERMISSIONS_UNSPECIFIED":
      return ScopePermissions.SCOPE_PERMISSIONS_UNSPECIFIED;
    case 1:
    case "SCOPE_PERMISSIONS_OVERRIDE_PARENT":
      return ScopePermissions.SCOPE_PERMISSIONS_OVERRIDE_PARENT;
    case 2:
    case "SCOPE_PERMISSIONS_REQUIRE_PARENTAL_CONSENT_FOR_ALLOWS":
      return ScopePermissions.SCOPE_PERMISSIONS_REQUIRE_PARENTAL_CONSENT_FOR_ALLOWS;
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ScopePermissions",
      );
  }
}

export function scopePermissionsToJSON(object: ScopePermissions): string {
  switch (object) {
    case ScopePermissions.SCOPE_PERMISSIONS_UNSPECIFIED:
      return "SCOPE_PERMISSIONS_UNSPECIFIED";
    case ScopePermissions.SCOPE_PERMISSIONS_OVERRIDE_PARENT:
      return "SCOPE_PERMISSIONS_OVERRIDE_PARENT";
    case ScopePermissions.SCOPE_PERMISSIONS_REQUIRE_PARENTAL_CONSENT_FOR_ALLOWS:
      return "SCOPE_PERMISSIONS_REQUIRE_PARENTAL_CONSENT_FOR_ALLOWS";
    default:
      throw new globalThis.Error(
        "Unrecognized enum value " + object + " for enum ScopePermissions",
      );
  }
}

export interface Policy {
  apiVersion: string;
  disabled: boolean;
  description: string;
  metadata: Metadata | undefined;
  policyType?:
    | { $case: "resourcePolicy"; resourcePolicy: ResourcePolicy }
    | { $case: "principalPolicy"; principalPolicy: PrincipalPolicy }
    | { $case: "derivedRoles"; derivedRoles: DerivedRoles }
    | { $case: "exportVariables"; exportVariables: ExportVariables }
    | { $case: "rolePolicy"; rolePolicy: RolePolicy }
    | { $case: "exportConstants"; exportConstants: ExportConstants }
    | undefined;
  variables: { [key: string]: string };
  jsonSchema: string;
}

export interface Policy_VariablesEntry {
  key: string;
  value: string;
}

export interface SourceAttributes {
  attributes: { [key: string]: any | undefined };
}

export interface SourceAttributes_AttributesEntry {
  key: string;
  value: any | undefined;
}

export interface Metadata {
  sourceFile: string;
  annotations: { [key: string]: string };
  hash: string | undefined;
  storeIdentifer: string;
  storeIdentifier: string;
  sourceAttributes: SourceAttributes | undefined;
}

export interface Metadata_AnnotationsEntry {
  key: string;
  value: string;
}

export interface ResourcePolicy {
  resource: string;
  version: string;
  importDerivedRoles: string[];
  rules: ResourceRule[];
  scope: string;
  schemas: Schemas | undefined;
  variables: Variables | undefined;
  scopePermissions: ScopePermissions;
  constants: Constants | undefined;
}

export interface ResourceRule {
  actions: string[];
  derivedRoles: string[];
  roles: string[];
  condition: Condition | undefined;
  effect: Effect;
  name: string;
  output: Output | undefined;
}

export interface RolePolicy {
  policyType?: { $case: "role"; role: string } | undefined;
  parentRoles: string[];
  scope: string;
  rules: RoleRule[];
  scopePermissions: ScopePermissions;
}

export interface RoleRule {
  resource: string;
  allowActions: string[];
}

export interface PrincipalPolicy {
  principal: string;
  version: string;
  rules: PrincipalRule[];
  scope: string;
  variables: Variables | undefined;
  scopePermissions: ScopePermissions;
  constants: Constants | undefined;
}

export interface PrincipalRule {
  resource: string;
  actions: PrincipalRule_Action[];
}

export interface PrincipalRule_Action {
  action: string;
  condition: Condition | undefined;
  effect: Effect;
  name: string;
  output: Output | undefined;
}

export interface DerivedRoles {
  name: string;
  definitions: RoleDef[];
  variables: Variables | undefined;
  constants: Constants | undefined;
}

export interface RoleDef {
  name: string;
  parentRoles: string[];
  condition: Condition | undefined;
}

export interface ExportConstants {
  name: string;
  definitions: { [key: string]: any | undefined };
}

export interface ExportConstants_DefinitionsEntry {
  key: string;
  value: any | undefined;
}

export interface Constants {
  import: string[];
  local: { [key: string]: any | undefined };
}

export interface Constants_LocalEntry {
  key: string;
  value: any | undefined;
}

export interface ExportVariables {
  name: string;
  definitions: { [key: string]: string };
}

export interface ExportVariables_DefinitionsEntry {
  key: string;
  value: string;
}

export interface Variables {
  import: string[];
  local: { [key: string]: string };
}

export interface Variables_LocalEntry {
  key: string;
  value: string;
}

export interface Condition {
  condition?:
    | { $case: "match"; match: Match }
    | { $case: "script"; script: string }
    | undefined;
}

export interface Match {
  op?:
    | { $case: "all"; all: Match_ExprList }
    | { $case: "any"; any: Match_ExprList }
    | { $case: "none"; none: Match_ExprList }
    | { $case: "expr"; expr: string }
    | undefined;
}

export interface Match_ExprList {
  of: Match[];
}

export interface Output {
  expr: string;
  when: Output_When | undefined;
}

export interface Output_When {
  ruleActivated: string;
  conditionNotMet: string;
}

export interface Schemas {
  principalSchema: Schemas_Schema | undefined;
  resourceSchema: Schemas_Schema | undefined;
}

export interface Schemas_IgnoreWhen {
  actions: string[];
}

export interface Schemas_Schema {
  ref: string;
  ignoreWhen: Schemas_IgnoreWhen | undefined;
}

function createBasePolicy(): Policy {
  return {
    apiVersion: "",
    disabled: false,
    description: "",
    metadata: undefined,
    policyType: undefined,
    variables: {},
    jsonSchema: "",
  };
}

export const Policy: MessageFns<Policy> = {
  encode(
    message: Policy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.apiVersion !== "") {
      writer.uint32(10).string(message.apiVersion);
    }
    if (message.disabled !== false) {
      writer.uint32(16).bool(message.disabled);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(34).fork()).join();
    }
    switch (message.policyType?.$case) {
      case "resourcePolicy":
        ResourcePolicy.encode(
          message.policyType.resourcePolicy,
          writer.uint32(42).fork(),
        ).join();
        break;
      case "principalPolicy":
        PrincipalPolicy.encode(
          message.policyType.principalPolicy,
          writer.uint32(50).fork(),
        ).join();
        break;
      case "derivedRoles":
        DerivedRoles.encode(
          message.policyType.derivedRoles,
          writer.uint32(58).fork(),
        ).join();
        break;
      case "exportVariables":
        ExportVariables.encode(
          message.policyType.exportVariables,
          writer.uint32(82).fork(),
        ).join();
        break;
      case "rolePolicy":
        RolePolicy.encode(
          message.policyType.rolePolicy,
          writer.uint32(90).fork(),
        ).join();
        break;
      case "exportConstants":
        ExportConstants.encode(
          message.policyType.exportConstants,
          writer.uint32(98).fork(),
        ).join();
        break;
    }
    Object.entries(message.variables).forEach(([key, value]) => {
      Policy_VariablesEntry.encode(
        { key: key as any, value },
        writer.uint32(66).fork(),
      ).join();
    });
    if (message.jsonSchema !== "") {
      writer.uint32(74).string(message.jsonSchema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Policy {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.apiVersion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.policyType = {
            $case: "resourcePolicy",
            resourcePolicy: ResourcePolicy.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.policyType = {
            $case: "principalPolicy",
            principalPolicy: PrincipalPolicy.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.policyType = {
            $case: "derivedRoles",
            derivedRoles: DerivedRoles.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.policyType = {
            $case: "exportVariables",
            exportVariables: ExportVariables.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.policyType = {
            $case: "rolePolicy",
            rolePolicy: RolePolicy.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.policyType = {
            $case: "exportConstants",
            exportConstants: ExportConstants.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = Policy_VariablesEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.variables[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.jsonSchema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy {
    return {
      apiVersion: isSet(object.apiVersion)
        ? globalThis.String(object.apiVersion)
        : "",
      disabled: isSet(object.disabled)
        ? globalThis.Boolean(object.disabled)
        : false,
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      metadata: isSet(object.metadata)
        ? Metadata.fromJSON(object.metadata)
        : undefined,
      policyType: isSet(object.resourcePolicy)
        ? {
            $case: "resourcePolicy",
            resourcePolicy: ResourcePolicy.fromJSON(object.resourcePolicy),
          }
        : isSet(object.principalPolicy)
          ? {
              $case: "principalPolicy",
              principalPolicy: PrincipalPolicy.fromJSON(object.principalPolicy),
            }
          : isSet(object.derivedRoles)
            ? {
                $case: "derivedRoles",
                derivedRoles: DerivedRoles.fromJSON(object.derivedRoles),
              }
            : isSet(object.exportVariables)
              ? {
                  $case: "exportVariables",
                  exportVariables: ExportVariables.fromJSON(
                    object.exportVariables,
                  ),
                }
              : isSet(object.rolePolicy)
                ? {
                    $case: "rolePolicy",
                    rolePolicy: RolePolicy.fromJSON(object.rolePolicy),
                  }
                : isSet(object.exportConstants)
                  ? {
                      $case: "exportConstants",
                      exportConstants: ExportConstants.fromJSON(
                        object.exportConstants,
                      ),
                    }
                  : undefined,
      variables: isObject(object.variables)
        ? Object.entries(object.variables).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
      jsonSchema: isSet(object.$schema)
        ? globalThis.String(object.$schema)
        : "",
    };
  },

  toJSON(message: Policy): unknown {
    const obj: any = {};
    if (message.apiVersion !== "") {
      obj.apiVersion = message.apiVersion;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.policyType?.$case === "resourcePolicy") {
      obj.resourcePolicy = ResourcePolicy.toJSON(
        message.policyType.resourcePolicy,
      );
    } else if (message.policyType?.$case === "principalPolicy") {
      obj.principalPolicy = PrincipalPolicy.toJSON(
        message.policyType.principalPolicy,
      );
    } else if (message.policyType?.$case === "derivedRoles") {
      obj.derivedRoles = DerivedRoles.toJSON(message.policyType.derivedRoles);
    } else if (message.policyType?.$case === "exportVariables") {
      obj.exportVariables = ExportVariables.toJSON(
        message.policyType.exportVariables,
      );
    } else if (message.policyType?.$case === "rolePolicy") {
      obj.rolePolicy = RolePolicy.toJSON(message.policyType.rolePolicy);
    } else if (message.policyType?.$case === "exportConstants") {
      obj.exportConstants = ExportConstants.toJSON(
        message.policyType.exportConstants,
      );
    }
    if (message.variables) {
      const entries = Object.entries(message.variables);
      if (entries.length > 0) {
        obj.variables = {};
        entries.forEach(([k, v]) => {
          obj.variables[k] = v;
        });
      }
    }
    if (message.jsonSchema !== "") {
      obj.$schema = message.jsonSchema;
    }
    return obj;
  },
};

function createBasePolicy_VariablesEntry(): Policy_VariablesEntry {
  return { key: "", value: "" };
}

export const Policy_VariablesEntry: MessageFns<Policy_VariablesEntry> = {
  encode(
    message: Policy_VariablesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Policy_VariablesEntry {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePolicy_VariablesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Policy_VariablesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Policy_VariablesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseSourceAttributes(): SourceAttributes {
  return { attributes: {} };
}

export const SourceAttributes: MessageFns<SourceAttributes> = {
  encode(
    message: SourceAttributes,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    Object.entries(message.attributes).forEach(([key, value]) => {
      if (value !== undefined) {
        SourceAttributes_AttributesEntry.encode(
          { key: key as any, value },
          writer.uint32(10).fork(),
        ).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SourceAttributes {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSourceAttributes();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = SourceAttributes_AttributesEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry1.value !== undefined) {
            message.attributes[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SourceAttributes {
    return {
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{
            [key: string]: any | undefined;
          }>((acc, [key, value]) => {
            acc[key] = value as any | undefined;
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: SourceAttributes): unknown {
    const obj: any = {};
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },
};

function createBaseSourceAttributes_AttributesEntry(): SourceAttributes_AttributesEntry {
  return { key: "", value: undefined };
}

export const SourceAttributes_AttributesEntry: MessageFns<SourceAttributes_AttributesEntry> =
  {
    encode(
      message: SourceAttributes_AttributesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        Value.encode(
          Value.wrap(message.value),
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): SourceAttributes_AttributesEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSourceAttributes_AttributesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SourceAttributes_AttributesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object?.value) ? object.value : undefined,
      };
    },

    toJSON(message: SourceAttributes_AttributesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = message.value;
      }
      return obj;
    },
  };

function createBaseMetadata(): Metadata {
  return {
    sourceFile: "",
    annotations: {},
    hash: undefined,
    storeIdentifer: "",
    storeIdentifier: "",
    sourceAttributes: undefined,
  };
}

export const Metadata: MessageFns<Metadata> = {
  encode(
    message: Metadata,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.sourceFile !== "") {
      writer.uint32(10).string(message.sourceFile);
    }
    Object.entries(message.annotations).forEach(([key, value]) => {
      Metadata_AnnotationsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    if (message.hash !== undefined) {
      UInt64Value.encode(
        { value: message.hash! },
        writer.uint32(26).fork(),
      ).join();
    }
    if (message.storeIdentifer !== "") {
      writer.uint32(34).string(message.storeIdentifer);
    }
    if (message.storeIdentifier !== "") {
      writer.uint32(42).string(message.storeIdentifier);
    }
    if (message.sourceAttributes !== undefined) {
      SourceAttributes.encode(
        message.sourceAttributes,
        writer.uint32(50).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Metadata {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceFile = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Metadata_AnnotationsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.annotations[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hash = UInt64Value.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.storeIdentifer = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.storeIdentifier = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.sourceAttributes = SourceAttributes.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Metadata {
    return {
      sourceFile: isSet(object.sourceFile)
        ? globalThis.String(object.sourceFile)
        : "",
      annotations: isObject(object.annotations)
        ? Object.entries(object.annotations).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
      hash: isSet(object.hash) ? String(object.hash) : undefined,
      storeIdentifer: isSet(object.storeIdentifer)
        ? globalThis.String(object.storeIdentifer)
        : "",
      storeIdentifier: isSet(object.storeIdentifier)
        ? globalThis.String(object.storeIdentifier)
        : "",
      sourceAttributes: isSet(object.sourceAttributes)
        ? SourceAttributes.fromJSON(object.sourceAttributes)
        : undefined,
    };
  },

  toJSON(message: Metadata): unknown {
    const obj: any = {};
    if (message.sourceFile !== "") {
      obj.sourceFile = message.sourceFile;
    }
    if (message.annotations) {
      const entries = Object.entries(message.annotations);
      if (entries.length > 0) {
        obj.annotations = {};
        entries.forEach(([k, v]) => {
          obj.annotations[k] = v;
        });
      }
    }
    if (message.hash !== undefined) {
      obj.hash = message.hash;
    }
    if (message.storeIdentifer !== "") {
      obj.storeIdentifer = message.storeIdentifer;
    }
    if (message.storeIdentifier !== "") {
      obj.storeIdentifier = message.storeIdentifier;
    }
    if (message.sourceAttributes !== undefined) {
      obj.sourceAttributes = SourceAttributes.toJSON(message.sourceAttributes);
    }
    return obj;
  },
};

function createBaseMetadata_AnnotationsEntry(): Metadata_AnnotationsEntry {
  return { key: "", value: "" };
}

export const Metadata_AnnotationsEntry: MessageFns<Metadata_AnnotationsEntry> =
  {
    encode(
      message: Metadata_AnnotationsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): Metadata_AnnotationsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMetadata_AnnotationsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): Metadata_AnnotationsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: Metadata_AnnotationsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },
  };

function createBaseResourcePolicy(): ResourcePolicy {
  return {
    resource: "",
    version: "",
    importDerivedRoles: [],
    rules: [],
    scope: "",
    schemas: undefined,
    variables: undefined,
    scopePermissions: 0,
    constants: undefined,
  };
}

export const ResourcePolicy: MessageFns<ResourcePolicy> = {
  encode(
    message: ResourcePolicy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.importDerivedRoles) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.rules) {
      ResourceRule.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.scope !== "") {
      writer.uint32(42).string(message.scope);
    }
    if (message.schemas !== undefined) {
      Schemas.encode(message.schemas, writer.uint32(50).fork()).join();
    }
    if (message.variables !== undefined) {
      Variables.encode(message.variables, writer.uint32(58).fork()).join();
    }
    if (message.scopePermissions !== 0) {
      writer.uint32(64).int32(message.scopePermissions);
    }
    if (message.constants !== undefined) {
      Constants.encode(message.constants, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourcePolicy {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.importDerivedRoles.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.rules.push(ResourceRule.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.schemas = Schemas.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.variables = Variables.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.scopePermissions = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.constants = Constants.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourcePolicy {
    return {
      resource: isSet(object.resource)
        ? globalThis.String(object.resource)
        : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      importDerivedRoles: globalThis.Array.isArray(object?.importDerivedRoles)
        ? object.importDerivedRoles.map((e: any) => globalThis.String(e))
        : [],
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => ResourceRule.fromJSON(e))
        : [],
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      schemas: isSet(object.schemas)
        ? Schemas.fromJSON(object.schemas)
        : undefined,
      variables: isSet(object.variables)
        ? Variables.fromJSON(object.variables)
        : undefined,
      scopePermissions: isSet(object.scopePermissions)
        ? scopePermissionsFromJSON(object.scopePermissions)
        : 0,
      constants: isSet(object.constants)
        ? Constants.fromJSON(object.constants)
        : undefined,
    };
  },

  toJSON(message: ResourcePolicy): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.importDerivedRoles?.length) {
      obj.importDerivedRoles = message.importDerivedRoles;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => ResourceRule.toJSON(e));
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.schemas !== undefined) {
      obj.schemas = Schemas.toJSON(message.schemas);
    }
    if (message.variables !== undefined) {
      obj.variables = Variables.toJSON(message.variables);
    }
    if (message.scopePermissions !== 0) {
      obj.scopePermissions = scopePermissionsToJSON(message.scopePermissions);
    }
    if (message.constants !== undefined) {
      obj.constants = Constants.toJSON(message.constants);
    }
    return obj;
  },
};

function createBaseResourceRule(): ResourceRule {
  return {
    actions: [],
    derivedRoles: [],
    roles: [],
    condition: undefined,
    effect: 0,
    name: "",
    output: undefined,
  };
}

export const ResourceRule: MessageFns<ResourceRule> = {
  encode(
    message: ResourceRule,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.actions) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.derivedRoles) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.roles) {
      writer.uint32(26).string(v!);
    }
    if (message.condition !== undefined) {
      Condition.encode(message.condition, writer.uint32(34).fork()).join();
    }
    if (message.effect !== 0) {
      writer.uint32(40).int32(message.effect);
    }
    if (message.name !== "") {
      writer.uint32(50).string(message.name);
    }
    if (message.output !== undefined) {
      Output.encode(message.output, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourceRule {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourceRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.derivedRoles.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.condition = Condition.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.effect = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.output = Output.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourceRule {
    return {
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => globalThis.String(e))
        : [],
      derivedRoles: globalThis.Array.isArray(object?.derivedRoles)
        ? object.derivedRoles.map((e: any) => globalThis.String(e))
        : [],
      roles: globalThis.Array.isArray(object?.roles)
        ? object.roles.map((e: any) => globalThis.String(e))
        : [],
      condition: isSet(object.condition)
        ? Condition.fromJSON(object.condition)
        : undefined,
      effect: isSet(object.effect) ? effectFromJSON(object.effect) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      output: isSet(object.output) ? Output.fromJSON(object.output) : undefined,
    };
  },

  toJSON(message: ResourceRule): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    if (message.derivedRoles?.length) {
      obj.derivedRoles = message.derivedRoles;
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    if (message.condition !== undefined) {
      obj.condition = Condition.toJSON(message.condition);
    }
    if (message.effect !== 0) {
      obj.effect = effectToJSON(message.effect);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.output !== undefined) {
      obj.output = Output.toJSON(message.output);
    }
    return obj;
  },
};

function createBaseRolePolicy(): RolePolicy {
  return {
    policyType: undefined,
    parentRoles: [],
    scope: "",
    rules: [],
    scopePermissions: 0,
  };
}

export const RolePolicy: MessageFns<RolePolicy> = {
  encode(
    message: RolePolicy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.policyType?.$case) {
      case "role":
        writer.uint32(10).string(message.policyType.role);
        break;
    }
    for (const v of message.parentRoles) {
      writer.uint32(42).string(v!);
    }
    if (message.scope !== "") {
      writer.uint32(18).string(message.scope);
    }
    for (const v of message.rules) {
      RoleRule.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.scopePermissions !== 0) {
      writer.uint32(32).int32(message.scopePermissions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RolePolicy {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRolePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.policyType = { $case: "role", role: reader.string() };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.parentRoles.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rules.push(RoleRule.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scopePermissions = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RolePolicy {
    return {
      policyType: isSet(object.role)
        ? { $case: "role", role: globalThis.String(object.role) }
        : undefined,
      parentRoles: globalThis.Array.isArray(object?.parentRoles)
        ? object.parentRoles.map((e: any) => globalThis.String(e))
        : [],
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => RoleRule.fromJSON(e))
        : [],
      scopePermissions: isSet(object.scopePermissions)
        ? scopePermissionsFromJSON(object.scopePermissions)
        : 0,
    };
  },

  toJSON(message: RolePolicy): unknown {
    const obj: any = {};
    if (message.policyType?.$case === "role") {
      obj.role = message.policyType.role;
    }
    if (message.parentRoles?.length) {
      obj.parentRoles = message.parentRoles;
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => RoleRule.toJSON(e));
    }
    if (message.scopePermissions !== 0) {
      obj.scopePermissions = scopePermissionsToJSON(message.scopePermissions);
    }
    return obj;
  },
};

function createBaseRoleRule(): RoleRule {
  return { resource: "", allowActions: [] };
}

export const RoleRule: MessageFns<RoleRule> = {
  encode(
    message: RoleRule,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    for (const v of message.allowActions) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleRule {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowActions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleRule {
    return {
      resource: isSet(object.resource)
        ? globalThis.String(object.resource)
        : "",
      allowActions: globalThis.Array.isArray(object?.allowActions)
        ? object.allowActions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RoleRule): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.allowActions?.length) {
      obj.allowActions = message.allowActions;
    }
    return obj;
  },
};

function createBasePrincipalPolicy(): PrincipalPolicy {
  return {
    principal: "",
    version: "",
    rules: [],
    scope: "",
    variables: undefined,
    scopePermissions: 0,
    constants: undefined,
  };
}

export const PrincipalPolicy: MessageFns<PrincipalPolicy> = {
  encode(
    message: PrincipalPolicy,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.principal !== "") {
      writer.uint32(10).string(message.principal);
    }
    if (message.version !== "") {
      writer.uint32(18).string(message.version);
    }
    for (const v of message.rules) {
      PrincipalRule.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.scope !== "") {
      writer.uint32(34).string(message.scope);
    }
    if (message.variables !== undefined) {
      Variables.encode(message.variables, writer.uint32(42).fork()).join();
    }
    if (message.scopePermissions !== 0) {
      writer.uint32(48).int32(message.scopePermissions);
    }
    if (message.constants !== undefined) {
      Constants.encode(message.constants, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrincipalPolicy {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipalPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.principal = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rules.push(PrincipalRule.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scope = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.variables = Variables.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scopePermissions = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.constants = Constants.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrincipalPolicy {
    return {
      principal: isSet(object.principal)
        ? globalThis.String(object.principal)
        : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      rules: globalThis.Array.isArray(object?.rules)
        ? object.rules.map((e: any) => PrincipalRule.fromJSON(e))
        : [],
      scope: isSet(object.scope) ? globalThis.String(object.scope) : "",
      variables: isSet(object.variables)
        ? Variables.fromJSON(object.variables)
        : undefined,
      scopePermissions: isSet(object.scopePermissions)
        ? scopePermissionsFromJSON(object.scopePermissions)
        : 0,
      constants: isSet(object.constants)
        ? Constants.fromJSON(object.constants)
        : undefined,
    };
  },

  toJSON(message: PrincipalPolicy): unknown {
    const obj: any = {};
    if (message.principal !== "") {
      obj.principal = message.principal;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.rules?.length) {
      obj.rules = message.rules.map((e) => PrincipalRule.toJSON(e));
    }
    if (message.scope !== "") {
      obj.scope = message.scope;
    }
    if (message.variables !== undefined) {
      obj.variables = Variables.toJSON(message.variables);
    }
    if (message.scopePermissions !== 0) {
      obj.scopePermissions = scopePermissionsToJSON(message.scopePermissions);
    }
    if (message.constants !== undefined) {
      obj.constants = Constants.toJSON(message.constants);
    }
    return obj;
  },
};

function createBasePrincipalRule(): PrincipalRule {
  return { resource: "", actions: [] };
}

export const PrincipalRule: MessageFns<PrincipalRule> = {
  encode(
    message: PrincipalRule,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.resource !== "") {
      writer.uint32(10).string(message.resource);
    }
    for (const v of message.actions) {
      PrincipalRule_Action.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrincipalRule {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipalRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resource = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.actions.push(
            PrincipalRule_Action.decode(reader, reader.uint32()),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrincipalRule {
    return {
      resource: isSet(object.resource)
        ? globalThis.String(object.resource)
        : "",
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => PrincipalRule_Action.fromJSON(e))
        : [],
    };
  },

  toJSON(message: PrincipalRule): unknown {
    const obj: any = {};
    if (message.resource !== "") {
      obj.resource = message.resource;
    }
    if (message.actions?.length) {
      obj.actions = message.actions.map((e) => PrincipalRule_Action.toJSON(e));
    }
    return obj;
  },
};

function createBasePrincipalRule_Action(): PrincipalRule_Action {
  return {
    action: "",
    condition: undefined,
    effect: 0,
    name: "",
    output: undefined,
  };
}

export const PrincipalRule_Action: MessageFns<PrincipalRule_Action> = {
  encode(
    message: PrincipalRule_Action,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.action !== "") {
      writer.uint32(10).string(message.action);
    }
    if (message.condition !== undefined) {
      Condition.encode(message.condition, writer.uint32(18).fork()).join();
    }
    if (message.effect !== 0) {
      writer.uint32(24).int32(message.effect);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.output !== undefined) {
      Output.encode(message.output, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): PrincipalRule_Action {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrincipalRule_Action();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.action = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.condition = Condition.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.effect = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.output = Output.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrincipalRule_Action {
    return {
      action: isSet(object.action) ? globalThis.String(object.action) : "",
      condition: isSet(object.condition)
        ? Condition.fromJSON(object.condition)
        : undefined,
      effect: isSet(object.effect) ? effectFromJSON(object.effect) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      output: isSet(object.output) ? Output.fromJSON(object.output) : undefined,
    };
  },

  toJSON(message: PrincipalRule_Action): unknown {
    const obj: any = {};
    if (message.action !== "") {
      obj.action = message.action;
    }
    if (message.condition !== undefined) {
      obj.condition = Condition.toJSON(message.condition);
    }
    if (message.effect !== 0) {
      obj.effect = effectToJSON(message.effect);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.output !== undefined) {
      obj.output = Output.toJSON(message.output);
    }
    return obj;
  },
};

function createBaseDerivedRoles(): DerivedRoles {
  return {
    name: "",
    definitions: [],
    variables: undefined,
    constants: undefined,
  };
}

export const DerivedRoles: MessageFns<DerivedRoles> = {
  encode(
    message: DerivedRoles,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.definitions) {
      RoleDef.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.variables !== undefined) {
      Variables.encode(message.variables, writer.uint32(26).fork()).join();
    }
    if (message.constants !== undefined) {
      Constants.encode(message.constants, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DerivedRoles {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivedRoles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.definitions.push(RoleDef.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.variables = Variables.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.constants = Constants.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DerivedRoles {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definitions: globalThis.Array.isArray(object?.definitions)
        ? object.definitions.map((e: any) => RoleDef.fromJSON(e))
        : [],
      variables: isSet(object.variables)
        ? Variables.fromJSON(object.variables)
        : undefined,
      constants: isSet(object.constants)
        ? Constants.fromJSON(object.constants)
        : undefined,
    };
  },

  toJSON(message: DerivedRoles): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definitions?.length) {
      obj.definitions = message.definitions.map((e) => RoleDef.toJSON(e));
    }
    if (message.variables !== undefined) {
      obj.variables = Variables.toJSON(message.variables);
    }
    if (message.constants !== undefined) {
      obj.constants = Constants.toJSON(message.constants);
    }
    return obj;
  },
};

function createBaseRoleDef(): RoleDef {
  return { name: "", parentRoles: [], condition: undefined };
}

export const RoleDef: MessageFns<RoleDef> = {
  encode(
    message: RoleDef,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    for (const v of message.parentRoles) {
      writer.uint32(18).string(v!);
    }
    if (message.condition !== undefined) {
      Condition.encode(message.condition, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleDef {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleDef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parentRoles.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.condition = Condition.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleDef {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      parentRoles: globalThis.Array.isArray(object?.parentRoles)
        ? object.parentRoles.map((e: any) => globalThis.String(e))
        : [],
      condition: isSet(object.condition)
        ? Condition.fromJSON(object.condition)
        : undefined,
    };
  },

  toJSON(message: RoleDef): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.parentRoles?.length) {
      obj.parentRoles = message.parentRoles;
    }
    if (message.condition !== undefined) {
      obj.condition = Condition.toJSON(message.condition);
    }
    return obj;
  },
};

function createBaseExportConstants(): ExportConstants {
  return { name: "", definitions: {} };
}

export const ExportConstants: MessageFns<ExportConstants> = {
  encode(
    message: ExportConstants,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.definitions).forEach(([key, value]) => {
      if (value !== undefined) {
        ExportConstants_DefinitionsEntry.encode(
          { key: key as any, value },
          writer.uint32(18).fork(),
        ).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportConstants {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportConstants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ExportConstants_DefinitionsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.definitions[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportConstants {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definitions: isObject(object.definitions)
        ? Object.entries(object.definitions).reduce<{
            [key: string]: any | undefined;
          }>((acc, [key, value]) => {
            acc[key] = value as any | undefined;
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: ExportConstants): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definitions) {
      const entries = Object.entries(message.definitions);
      if (entries.length > 0) {
        obj.definitions = {};
        entries.forEach(([k, v]) => {
          obj.definitions[k] = v;
        });
      }
    }
    return obj;
  },
};

function createBaseExportConstants_DefinitionsEntry(): ExportConstants_DefinitionsEntry {
  return { key: "", value: undefined };
}

export const ExportConstants_DefinitionsEntry: MessageFns<ExportConstants_DefinitionsEntry> =
  {
    encode(
      message: ExportConstants_DefinitionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== undefined) {
        Value.encode(
          Value.wrap(message.value),
          writer.uint32(18).fork(),
        ).join();
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ExportConstants_DefinitionsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseExportConstants_DefinitionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ExportConstants_DefinitionsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object?.value) ? object.value : undefined,
      };
    },

    toJSON(message: ExportConstants_DefinitionsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== undefined) {
        obj.value = message.value;
      }
      return obj;
    },
  };

function createBaseConstants(): Constants {
  return { import: [], local: {} };
}

export const Constants: MessageFns<Constants> = {
  encode(
    message: Constants,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.import) {
      writer.uint32(10).string(v!);
    }
    Object.entries(message.local).forEach(([key, value]) => {
      if (value !== undefined) {
        Constants_LocalEntry.encode(
          { key: key as any, value },
          writer.uint32(18).fork(),
        ).join();
      }
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Constants {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstants();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.import.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Constants_LocalEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.local[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Constants {
    return {
      import: globalThis.Array.isArray(object?.import)
        ? object.import.map((e: any) => globalThis.String(e))
        : [],
      local: isObject(object.local)
        ? Object.entries(object.local).reduce<{
            [key: string]: any | undefined;
          }>((acc, [key, value]) => {
            acc[key] = value as any | undefined;
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: Constants): unknown {
    const obj: any = {};
    if (message.import?.length) {
      obj.import = message.import;
    }
    if (message.local) {
      const entries = Object.entries(message.local);
      if (entries.length > 0) {
        obj.local = {};
        entries.forEach(([k, v]) => {
          obj.local[k] = v;
        });
      }
    }
    return obj;
  },
};

function createBaseConstants_LocalEntry(): Constants_LocalEntry {
  return { key: "", value: undefined };
}

export const Constants_LocalEntry: MessageFns<Constants_LocalEntry> = {
  encode(
    message: Constants_LocalEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Constants_LocalEntry {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConstants_LocalEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Constants_LocalEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object?.value) ? object.value : undefined,
    };
  },

  toJSON(message: Constants_LocalEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseExportVariables(): ExportVariables {
  return { name: "", definitions: {} };
}

export const ExportVariables: MessageFns<ExportVariables> = {
  encode(
    message: ExportVariables,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    Object.entries(message.definitions).forEach(([key, value]) => {
      ExportVariables_DefinitionsEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExportVariables {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExportVariables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ExportVariables_DefinitionsEntry.decode(
            reader,
            reader.uint32(),
          );
          if (entry2.value !== undefined) {
            message.definitions[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExportVariables {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      definitions: isObject(object.definitions)
        ? Object.entries(object.definitions).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: ExportVariables): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.definitions) {
      const entries = Object.entries(message.definitions);
      if (entries.length > 0) {
        obj.definitions = {};
        entries.forEach(([k, v]) => {
          obj.definitions[k] = v;
        });
      }
    }
    return obj;
  },
};

function createBaseExportVariables_DefinitionsEntry(): ExportVariables_DefinitionsEntry {
  return { key: "", value: "" };
}

export const ExportVariables_DefinitionsEntry: MessageFns<ExportVariables_DefinitionsEntry> =
  {
    encode(
      message: ExportVariables_DefinitionsEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(
      input: BinaryReader | Uint8Array,
      length?: number,
    ): ExportVariables_DefinitionsEntry {
      const reader =
        input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseExportVariables_DefinitionsEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): ExportVariables_DefinitionsEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: ExportVariables_DefinitionsEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },
  };

function createBaseVariables(): Variables {
  return { import: [], local: {} };
}

export const Variables: MessageFns<Variables> = {
  encode(
    message: Variables,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.import) {
      writer.uint32(10).string(v!);
    }
    Object.entries(message.local).forEach(([key, value]) => {
      Variables_LocalEntry.encode(
        { key: key as any, value },
        writer.uint32(18).fork(),
      ).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Variables {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariables();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.import.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = Variables_LocalEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.local[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variables {
    return {
      import: globalThis.Array.isArray(object?.import)
        ? object.import.map((e: any) => globalThis.String(e))
        : [],
      local: isObject(object.local)
        ? Object.entries(object.local).reduce<{ [key: string]: string }>(
            (acc, [key, value]) => {
              acc[key] = String(value);
              return acc;
            },
            {},
          )
        : {},
    };
  },

  toJSON(message: Variables): unknown {
    const obj: any = {};
    if (message.import?.length) {
      obj.import = message.import;
    }
    if (message.local) {
      const entries = Object.entries(message.local);
      if (entries.length > 0) {
        obj.local = {};
        entries.forEach(([k, v]) => {
          obj.local[k] = v;
        });
      }
    }
    return obj;
  },
};

function createBaseVariables_LocalEntry(): Variables_LocalEntry {
  return { key: "", value: "" };
}

export const Variables_LocalEntry: MessageFns<Variables_LocalEntry> = {
  encode(
    message: Variables_LocalEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Variables_LocalEntry {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVariables_LocalEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Variables_LocalEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: Variables_LocalEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
};

function createBaseCondition(): Condition {
  return { condition: undefined };
}

export const Condition: MessageFns<Condition> = {
  encode(
    message: Condition,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.condition?.$case) {
      case "match":
        Match.encode(message.condition.match, writer.uint32(10).fork()).join();
        break;
      case "script":
        writer.uint32(18).string(message.condition.script);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Condition {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCondition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.condition = {
            $case: "match",
            match: Match.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.condition = { $case: "script", script: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Condition {
    return {
      condition: isSet(object.match)
        ? { $case: "match", match: Match.fromJSON(object.match) }
        : isSet(object.script)
          ? { $case: "script", script: globalThis.String(object.script) }
          : undefined,
    };
  },

  toJSON(message: Condition): unknown {
    const obj: any = {};
    if (message.condition?.$case === "match") {
      obj.match = Match.toJSON(message.condition.match);
    } else if (message.condition?.$case === "script") {
      obj.script = message.condition.script;
    }
    return obj;
  },
};

function createBaseMatch(): Match {
  return { op: undefined };
}

export const Match: MessageFns<Match> = {
  encode(
    message: Match,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    switch (message.op?.$case) {
      case "all":
        Match_ExprList.encode(message.op.all, writer.uint32(10).fork()).join();
        break;
      case "any":
        Match_ExprList.encode(message.op.any, writer.uint32(18).fork()).join();
        break;
      case "none":
        Match_ExprList.encode(message.op.none, writer.uint32(26).fork()).join();
        break;
      case "expr":
        writer.uint32(34).string(message.op.expr);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Match {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.op = {
            $case: "all",
            all: Match_ExprList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.op = {
            $case: "any",
            any: Match_ExprList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.op = {
            $case: "none",
            none: Match_ExprList.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.op = { $case: "expr", expr: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Match {
    return {
      op: isSet(object.all)
        ? { $case: "all", all: Match_ExprList.fromJSON(object.all) }
        : isSet(object.any)
          ? { $case: "any", any: Match_ExprList.fromJSON(object.any) }
          : isSet(object.none)
            ? { $case: "none", none: Match_ExprList.fromJSON(object.none) }
            : isSet(object.expr)
              ? { $case: "expr", expr: globalThis.String(object.expr) }
              : undefined,
    };
  },

  toJSON(message: Match): unknown {
    const obj: any = {};
    if (message.op?.$case === "all") {
      obj.all = Match_ExprList.toJSON(message.op.all);
    } else if (message.op?.$case === "any") {
      obj.any = Match_ExprList.toJSON(message.op.any);
    } else if (message.op?.$case === "none") {
      obj.none = Match_ExprList.toJSON(message.op.none);
    } else if (message.op?.$case === "expr") {
      obj.expr = message.op.expr;
    }
    return obj;
  },
};

function createBaseMatch_ExprList(): Match_ExprList {
  return { of: [] };
}

export const Match_ExprList: MessageFns<Match_ExprList> = {
  encode(
    message: Match_ExprList,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.of) {
      Match.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Match_ExprList {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMatch_ExprList();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.of.push(Match.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Match_ExprList {
    return {
      of: globalThis.Array.isArray(object?.of)
        ? object.of.map((e: any) => Match.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Match_ExprList): unknown {
    const obj: any = {};
    if (message.of?.length) {
      obj.of = message.of.map((e) => Match.toJSON(e));
    }
    return obj;
  },
};

function createBaseOutput(): Output {
  return { expr: "", when: undefined };
}

export const Output: MessageFns<Output> = {
  encode(
    message: Output,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.expr !== "") {
      writer.uint32(10).string(message.expr);
    }
    if (message.when !== undefined) {
      Output_When.encode(message.when, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Output {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expr = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.when = Output_When.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Output {
    return {
      expr: isSet(object.expr) ? globalThis.String(object.expr) : "",
      when: isSet(object.when) ? Output_When.fromJSON(object.when) : undefined,
    };
  },

  toJSON(message: Output): unknown {
    const obj: any = {};
    if (message.expr !== "") {
      obj.expr = message.expr;
    }
    if (message.when !== undefined) {
      obj.when = Output_When.toJSON(message.when);
    }
    return obj;
  },
};

function createBaseOutput_When(): Output_When {
  return { ruleActivated: "", conditionNotMet: "" };
}

export const Output_When: MessageFns<Output_When> = {
  encode(
    message: Output_When,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ruleActivated !== "") {
      writer.uint32(10).string(message.ruleActivated);
    }
    if (message.conditionNotMet !== "") {
      writer.uint32(18).string(message.conditionNotMet);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Output_When {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOutput_When();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ruleActivated = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.conditionNotMet = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Output_When {
    return {
      ruleActivated: isSet(object.ruleActivated)
        ? globalThis.String(object.ruleActivated)
        : "",
      conditionNotMet: isSet(object.conditionNotMet)
        ? globalThis.String(object.conditionNotMet)
        : "",
    };
  },

  toJSON(message: Output_When): unknown {
    const obj: any = {};
    if (message.ruleActivated !== "") {
      obj.ruleActivated = message.ruleActivated;
    }
    if (message.conditionNotMet !== "") {
      obj.conditionNotMet = message.conditionNotMet;
    }
    return obj;
  },
};

function createBaseSchemas(): Schemas {
  return { principalSchema: undefined, resourceSchema: undefined };
}

export const Schemas: MessageFns<Schemas> = {
  encode(
    message: Schemas,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.principalSchema !== undefined) {
      Schemas_Schema.encode(
        message.principalSchema,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.resourceSchema !== undefined) {
      Schemas_Schema.encode(
        message.resourceSchema,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schemas {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemas();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.principalSchema = Schemas_Schema.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resourceSchema = Schemas_Schema.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schemas {
    return {
      principalSchema: isSet(object.principalSchema)
        ? Schemas_Schema.fromJSON(object.principalSchema)
        : undefined,
      resourceSchema: isSet(object.resourceSchema)
        ? Schemas_Schema.fromJSON(object.resourceSchema)
        : undefined,
    };
  },

  toJSON(message: Schemas): unknown {
    const obj: any = {};
    if (message.principalSchema !== undefined) {
      obj.principalSchema = Schemas_Schema.toJSON(message.principalSchema);
    }
    if (message.resourceSchema !== undefined) {
      obj.resourceSchema = Schemas_Schema.toJSON(message.resourceSchema);
    }
    return obj;
  },
};

function createBaseSchemas_IgnoreWhen(): Schemas_IgnoreWhen {
  return { actions: [] };
}

export const Schemas_IgnoreWhen: MessageFns<Schemas_IgnoreWhen> = {
  encode(
    message: Schemas_IgnoreWhen,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    for (const v of message.actions) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): Schemas_IgnoreWhen {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemas_IgnoreWhen();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.actions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schemas_IgnoreWhen {
    return {
      actions: globalThis.Array.isArray(object?.actions)
        ? object.actions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Schemas_IgnoreWhen): unknown {
    const obj: any = {};
    if (message.actions?.length) {
      obj.actions = message.actions;
    }
    return obj;
  },
};

function createBaseSchemas_Schema(): Schemas_Schema {
  return { ref: "", ignoreWhen: undefined };
}

export const Schemas_Schema: MessageFns<Schemas_Schema> = {
  encode(
    message: Schemas_Schema,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.ref !== "") {
      writer.uint32(10).string(message.ref);
    }
    if (message.ignoreWhen !== undefined) {
      Schemas_IgnoreWhen.encode(
        message.ignoreWhen,
        writer.uint32(18).fork(),
      ).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Schemas_Schema {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchemas_Schema();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ignoreWhen = Schemas_IgnoreWhen.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Schemas_Schema {
    return {
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      ignoreWhen: isSet(object.ignoreWhen)
        ? Schemas_IgnoreWhen.fromJSON(object.ignoreWhen)
        : undefined,
    };
  },

  toJSON(message: Schemas_Schema): unknown {
    const obj: any = {};
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.ignoreWhen !== undefined) {
      obj.ignoreWhen = Schemas_IgnoreWhen.toJSON(message.ignoreWhen);
    }
    return obj;
  },
};

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
}
